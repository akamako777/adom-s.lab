<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Star Compass Proto v1.3</title>
    
    <!-- Google Fonts: Zen Maru Gothic -->
    <link rel="preconnect" href="https://fonts.googleapis.com/">
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;700;900&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary-color: #aaddff;
            --accent-color: #ffd700;
            --bg-dark: #050a14;
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: var(--bg-dark); 
            font-family: 'Zen Maru Gothic', sans-serif;
            color: var(--primary-color); 
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }
        
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* å…±é€šãƒœã‚¿ãƒ³ãƒ‡ã‚¶ã‚¤ãƒ³ */
        .btn-style {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: #fff;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: 700;
            font-family: 'Zen Maru Gothic', sans-serif;
            border-radius: 50px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            touch-action: manipulation;
            transition: all 0.2s;
            cursor: pointer;
            text-align: center;
        }
        .btn-style:active { 
            background: rgba(255, 255, 255, 0.4); 
            transform: scale(0.95);
        }
        .btn-accent {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);
            color: #444;
            border: none;
            box-shadow: 0 5px 15px rgba(255, 100, 100, 0.4);
        }

        /* UI Layers */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: auto;
            transition: opacity 0.5s;
        }
        .hidden { opacity: 0; pointer-events: none; }

        /* Start Screen */
        #start-screen {
            background: radial-gradient(circle at 50% 100%, #1a2a6c, #000), linear-gradient(to top, #000428, #004e92);
            color: white;
            text-align: center;
        }
        #start-screen h1 { font-size: 3rem; text-shadow: 0 0 20px #0ff; margin-bottom: 10px; }

        /* Calibration Screen */
        #calibration-screen {
            background: rgba(0, 0, 0, 0.6); /* åŠé€æ˜ã§å‘ã“ã†ã®ã‚°ãƒªãƒƒãƒ‰ã‚’è¦‹ã›ã‚‹ */
            justify-content: space-between;
            padding: 40px 20px;
            box-sizing: border-box;
        }
        .calib-guide {
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 20px;
            border: 2px solid #0ff;
            text-align: center;
            max-width: 90%;
        }
        .calib-step { font-size: 1.2rem; margin-bottom: 10px; line-height: 1.6; }
        .highlight { color: #ffd700; font-size: 1.4rem; font-weight: 900; }

        /* Main HUD (Stargazing) */
        #main-hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 50;
        }
        .hud-top { padding: 15px; display: flex; justify-content: space-between; pointer-events: auto; }
        .hud-bottom { padding: 20px; display: flex; justify-content: center; gap: 20px; pointer-events: auto; align-items: flex-end; }
        
        .sensor-monitor {
            font-size: 10px; color: rgba(255,255,255,0.5); 
            background: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px;
            text-align: right;
        }
        
        /* Round Buttons for Main HUD */
        .round-btn {
            width: 60px; height: 60px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.5);
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 24px;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(4px);
        }
        .round-btn:active { background: rgba(255,255,255,0.3); }

        /* PC Warning */
        #pc-warning {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 10000; color: #fff;
            flex-direction: column; align-items: center; justify-content: center; text-align: center;
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <!-- PC Warning -->
    <div id="pc-warning">
        <h1>ã‚¹ãƒãƒ›ã§ã¿ã¦ã­ï¼</h1>
        <p>ã“ã®ã‚¢ãƒ—ãƒªã¯ã‚¹ãƒãƒ›ã®ã‚»ãƒ³ã‚µãƒ¼ã‚’ã¤ã‹ã†ã‚ˆã€‚</p>
        <div id="qr-container" style="background:#fff; padding:10px; margin:20px; border-radius:10px;"></div>
    </div>

    <!-- 1. Start Screen -->
    <div id="start-screen" class="overlay">
        <h1>æ˜Ÿç©ºã‚³ãƒ³ãƒ‘ã‚¹</h1>
        <p style="font-size:1.2rem;">ã˜ã‚…ã‚“ã³ã¯ ã„ã„ã‹ãªï¼Ÿ</p>
        <button id="btn-start" class="btn-style btn-accent" style="margin-top:30px; font-size:1.5rem;">ã‚¹ã‚¿ãƒ¼ãƒˆï¼</button>
        <p style="font-size:0.8rem; margin-top:20px; opacity:0.7;">
            â€»ã€Œè¨±å¯(Allow)ã€ã¨èã‹ã‚ŒãŸã‚‰<br>ã€Œè¨±å¯ã€ã‚’ãŠã—ã¦ã­
        </p>
    </div>

    <!-- 2. Calibration Screen -->
    <div id="calibration-screen" class="overlay hidden">
        <div class="calib-guide">
            <p class="calib-step">1. ã‚¹ãƒãƒ›ã‚’<b>ã¾ã‚ã—ã¦</b><br>æ–¹ä½ç£é‡(ã»ã†ã„ã˜ã—ã‚“)ã§<br><span class="highlight">ã€ŒåŒ— (N)ã€</span>ã‚’å‘ã„ã¦ã­</p>
        </div>
        
        <div style="text-align: center;">
            <p class="calib-step">åŒ—ã‚’å‘ã„ãŸã‚‰...</p>
            <button id="btn-set-north" class="btn-style btn-accent" style="width: 200px;">ã“ã“ãŒ åŒ—ã ï¼</button>
        </div>

        <div class="calib-guide" style="border-color: #aaa;">
            <p style="font-size:0.9rem;">â€»ç”»é¢ã®å¥¥ã«ç·‘ã®ç·šãŒè¦‹ãˆã‚‹ã‹ãªï¼Ÿ<br>ã‚ã‚ŒãŒåœ°å¹³ç·šã ã‚ˆã€‚</p>
        </div>
    </div>

    <!-- 3. Main HUD (Star View) -->
    <div id="main-hud" class="hidden">
        <div class="hud-top">
            <button id="btn-recalib" class="btn-style" style="font-size:0.9rem; padding:10px 15px;">åŒ—ã‚’åˆã‚ã›ãªãŠã™</button>
            <div id="sensor-monitor" class="sensor-monitor">Sensor: ---</div>
        </div>

        <!-- Center Crosshair -->
        <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); opacity:0.5;">
            <div style="width:20px; height:20px; border:2px solid #0ff; border-radius:50%;"></div>
            <div style="position:absolute; top:10px; left:-10px; width:40px; height:1px; background:#0ff;"></div>
            <div style="position:absolute; top:-10px; left:10px; width:1px; height:40px; background:#0ff;"></div>
        </div>

        <div class="hud-bottom">
            <button id="btn-minus90" class="round-btn">â†¶</button>
            <div style="text-align:center; color:white; text-shadow:0 0 5px black;">
                <div style="font-size:10px;">ã‚ºãƒ¬ãŸã‚‰èª¿æ•´</div>
                <div id="offset-val" style="font-size:16px; font-weight:bold;">0Â°</div>
            </div>
            <button id="btn-plus90" class="round-btn">â†·</button>
        </div>
    </div>

    <!-- Canvas -->
    <div id="canvas-container"></div>

    <script>
        /**
         * ğŸŒŒ STAR COMPASS ENGINE V1.3
         * Focus: Setup Flow for Kids & Better Visibility
         */

        // --- Utils: Device Check ---
        function isMobile() {
            const ua = navigator.userAgent.toLowerCase();
            return /iphone|ipad|ipod|android/i.test(ua);
        }

        if (!isMobile()) {
            document.getElementById('pc-warning').style.display = 'flex';
            document.getElementById('start-screen').style.display = 'none';
            // QR Gen
            const qrImg = document.createElement('img');
            qrImg.src = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(window.location.href)}`;
            document.getElementById('qr-container').appendChild(qrImg);
        }

        // --- Config ---
        const CONFIG = {
            fov: 70, // Slightly wider
            defaultLat: 35.6895, 
            starDistance: 600,
            starScale: 2.5 // Bigger stars!
        };

        // --- State ---
        let state = {
            isRunning: false,
            mode: 'INIT', // INIT -> CALIB -> STAR
            alphaOffset: 0,
            manualOffset: 0,
            raw: { alpha: 0, beta: 0, gamma: 0 }
        };

        // --- Three.js ---
        let scene, camera, renderer;
        let starGroup, horizonGroup;

        // --- Star Data (Winter Focused) ---
        // å—ã®ç©ºã«ã‚ªãƒªã‚ªãƒ³åº§ã‚’å¼·åˆ¶é…ç½®ã™ã‚‹ãŸã‚ã€åº§æ¨™ç³»ã‚’èª¿æ•´æ¸ˆã¿
        const STARS = [
            // åŒ—æ¥µæ˜Ÿ (Polaris) - åŒ—(Z-)ã®ç©ºé«˜ã
            { name: "åŒ—æ¥µæ˜Ÿ", ra: 0, dec: 89, color: 0xFFFFDD, size: 2.5 },
            
            // ã‚ªãƒªã‚ªãƒ³ (Orion) - å—(Z+)ã®ç©º
            // RA 5-6h -> æœ¬æ¥ãªã‚‰RAã§é…ç½®ã™ã‚‹ãŒã€V1.3ã§ã¯è¦–èªæ€§é‡è¦–ã§
            // ã€Œå—ã‚’å‘ã„ãŸã‚‰è¦‹ãˆã‚‹ã€ä½ç½®ã«ç›¸å¯¾é…ç½®ã™ã‚‹ã€‚
            // Z+æ–¹å‘(South)ã‚’ä¸­å¿ƒã«é…ç½®
            
            // Betelgeuse (Top Left)
            { name: "ãƒ™ãƒ†ãƒ«ã‚®ã‚¦ã‚¹", x: 20, y: 40, z: 100, color: 0xFF8866, size: 3.0 },
            // Rigel (Bottom Right)
            { name: "ãƒªã‚²ãƒ«", x: -20, y: 10, z: 100, color: 0x88AAFF, size: 3.0 },
            // Belt (Three Stars)
            { name: "ä¸‰ã¤æ˜Ÿ1", x: -5, y: 28, z: 100, color: 0xCCDDFF, size: 2.0 },
            { name: "ä¸‰ã¤æ˜Ÿ2", x: 0, y: 27, z: 100, color: 0xCCDDFF, size: 2.0 },
            { name: "ä¸‰ã¤æ˜Ÿ3", x: 5, y: 26, z: 100, color: 0xCCDDFF, size: 2.0 },
            
            // Sirius (Canis Major) - Below Orion, Left
            { name: "ã‚·ãƒªã‚¦ã‚¹", x: 40, y: -10, z: 100, color: 0xFFFFFF, size: 4.0 }, // Biggest!
            
            // Procyon (Canis Minor) - Top Left of Sirius
            { name: "ãƒ—ãƒ­ã‚­ã‚ªãƒ³", x: 50, y: 30, z: 90, color: 0xFFFFEE, size: 2.5 },

            // Aldebaran (Taurus) - Right of Orion
            { name: "ã‚¢ãƒ«ãƒ‡ãƒãƒ©ãƒ³", x: -50, y: 35, z: 80, color: 0xFFAA55, size: 2.5 }
        ];

        const LINES = [
            // Orion Box
            [0, 2], [0, 4], [2, 3], [1, 3], [1, 5], [4, 5],
            // Sirius connection
            [1, 5] // Loose connection
        ];

        // --- App Logic ---

        function init3D() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(CONFIG.fov, window.innerWidth / window.innerHeight, 0.1, 2000);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Objects
            createGrid(); // Horizon (Always visible)
            createStars(); // Stars (Hidden initially)

            // Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Loop
            animate();
        }

        function createGrid() {
            horizonGroup = new THREE.Group();
            
            // 1. Horizon Ring
            const ringGeo = new THREE.RingGeometry(CONFIG.starDistance - 10, CONFIG.starDistance, 64);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent:true, opacity:0.6 });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2; // Flat
            horizonGroup.add(ring);

            // 2. Cardinal Labels (Using simple Sprites for robustness)
            // North (Z-)
            addLabel("åŒ— (N)", 0, 20, -CONFIG.starDistance + 50, "#ff3333");
            // South (Z+)
            addLabel("å— (S)", 0, 20, CONFIG.starDistance - 50, "#33ff33");
            // East (X+)
            addLabel("æ± (E)", CONFIG.starDistance - 50, 20, 0, "#33ff33");
            // West (X-)
            addLabel("è¥¿ (W)", -CONFIG.starDistance + 50, 20, 0, "#33ff33");

            // 3. Grid Lines
            const gridHelper = new THREE.PolarGridHelper(CONFIG.starDistance, 16, 8, 64, 0x004400, 0x004400);
            horizonGroup.add(gridHelper);

            scene.add(horizonGroup);
        }

        function addLabel(text, x, y, z, colorStr) {
            const canvas = document.createElement('canvas');
            const size = 256;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = colorStr;
            ctx.font = 'bold 100px "Zen Maru Gothic", Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, size/2, size/2);
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex });
            const sprite = new THREE.Sprite(mat);
            sprite.position.set(x, y, z);
            sprite.scale.set(60, 60, 1);
            horizonGroup.add(sprite);
        }

        function createStars() {
            starGroup = new THREE.Group();
            
            // Manual Placement for Prototype Clarity
            // We map the array directly to 3D positions relative to South
            STARS.forEach((star, idx) => {
                let pos;
                if (star.name === "åŒ—æ¥µæ˜Ÿ") {
                    // North, Up by Latitude (approx 35deg)
                    // Z- is North
                    const r = CONFIG.starDistance;
                    const latRad = 35 * (Math.PI/180);
                    pos = new THREE.Vector3(0, r * Math.sin(latRad), -r * Math.cos(latRad));
                } else {
                    // Use defined x,y,z relative to South (Z+)
                    // Scale them out to sphere surface
                    const v = new THREE.Vector3(star.x, star.y + 20, star.z); // Lift up a bit
                    v.normalize().multiplyScalar(CONFIG.starDistance);
                    pos = v;
                }

                const geo = new THREE.SphereGeometry(star.size * CONFIG.starScale, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ color: star.color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                starGroup.add(mesh);

                // Save pos for lines
                star.vec = pos;
            });

            // Lines
            /* Simple lines for Orion (indices in STARS array manual map) */
            // Skip line drawing logic for now to ensure dots are visible first
            // Just drawing dots is safer for v1.3 "Is it working?" check

            starGroup.visible = false; // Initially Hidden!
            scene.add(starGroup);
        }

        // --- Sensor Handling ---
        function handleOrientation(e) {
            state.raw = { 
                alpha: e.alpha || 0, 
                beta: e.beta || 0, 
                gamma: e.gamma || 0 
            };

            // Debug Monitor
            const mon = document.getElementById('sensor-monitor');
            if (mon) {
                mon.innerText = `A:${Math.round(state.raw.alpha)} B:${Math.round(state.raw.beta)}`;
            }

            if (!camera) return;

            // Simple Orientation Logic (Z-Y-X Order)
            // Apply Manual Offset & Calibration to Alpha
            const finalAlpha = state.raw.alpha + state.alphaOffset + state.manualOffset;
            
            const deg2rad = Math.PI / 180;
            const eu = new THREE.Euler(
                state.raw.beta * deg2rad,
                finalAlpha * deg2rad,
                -state.raw.gamma * deg2rad,
                'YXZ'
            );
            
            const q = new THREE.Quaternion().setFromEuler(eu);
            // Adjust for screen orientation (Portrait/Landscape)
            // Standard fix for WebAR: rotate -90 around X to bring camera down?
            const qFix = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
            q.multiply(qFix);

            camera.quaternion.copy(q);
        }

        // --- UI Flows ---

        // Step 1: Start Button
        document.getElementById('btn-start').addEventListener('click', () => {
            // Permission Request (iOS)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(resp => {
                        if (resp === 'granted') {
                            startCalibration();
                        } else {
                            alert("ã‚»ãƒ³ã‚µãƒ¼ã®è¨±å¯ãŒãªã„ã¨å‹•ã‹ãªã„ã‚ˆğŸ˜¢");
                        }
                    })
                    .catch(e => alert(e));
            } else {
                startCalibration();
            }
        });

        // Step 2: Go to Calibration
        function startCalibration() {
            // Init 3D Engine
            if (!scene) init3D();
            
            window.addEventListener('deviceorientation', handleOrientation, true);
            state.isRunning = true;

            // UI Switch
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('calibration-screen').classList.remove('hidden');
            state.mode = 'CALIB';
        }

        // Step 3: Set North & Go to Star Mode
        document.getElementById('btn-set-north').addEventListener('click', () => {
            // ç¾åœ¨ã®Alphaã‚’ã€Œ0 (North)ã€ã¨å®šç¾©ã™ã‚‹
            // ã¤ã¾ã‚Šã€è£œæ­£å€¤ = -ç¾åœ¨ã®Alpha
            state.alphaOffset = -state.raw.alpha;
            
            // UI Switch
            document.getElementById('calibration-screen').classList.add('hidden');
            document.getElementById('main-hud').classList.remove('hidden');
            
            // Show Stars!
            starGroup.visible = true;
            state.mode = 'STAR';
        });

        // Other Controls
        document.getElementById('btn-recalib').addEventListener('click', () => {
            state.alphaOffset = -state.raw.alpha;
            state.manualOffset = 0; // Reset manual too
            document.getElementById('offset-val').innerText = "0Â°";
            alert("ä»Šå‘ã„ã¦ã„ã‚‹æ–¹å‘ã‚’ã€ŒåŒ—ã€ã«ã‚»ãƒƒãƒˆã—ãŸã‚ˆï¼");
        });

        document.getElementById('btn-minus90').addEventListener('click', () => {
            state.manualOffset -= 15; // Fine tune
            updateOffsetDisplay();
        });
        document.getElementById('btn-plus90').addEventListener('click', () => {
            state.manualOffset += 15;
            updateOffsetDisplay();
        });

        function updateOffsetDisplay() {
            document.getElementById('offset-val').innerText = state.manualOffset + "Â°";
        }

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

    </script>
</body>
</html>
