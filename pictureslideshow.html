<!DOCTYPE html>
<html lang="ja" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simple Memories - Slideshow Maker</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Zen Kaku Gothic New"', '"Noto Sans JP"', '"Noto Sans TC"', '"Noto Sans Devanagari"', 'sans-serif'],
                        maru: ['"Zen Maru Gothic"', 'sans-serif'],
                    },
                    colors: {
                        dark: {
                            bg: '#0f172a',
                            surface: '#1e293b',
                            text: '#f1f5f9',
                            muted: '#94a3b8'
                        }
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.3s ease-out',
                        'bounce-in': 'bounceIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0', transform: 'translateY(10px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' },
                        },
                        bounceIn: {
                            '0%': { opacity: '0', transform: 'scale(0.9)' },
                            '100%': { opacity: '1', transform: 'scale(1)' },
                        }
                    }
                }
            }
        }
    </script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* Google Fonts Import */
        @import url('https://fonts.googleapis.com/css2?family=Zen+Kaku+Gothic+New:wght@400;500;700&family=Zen+Maru+Gothic:wght@500;700;900&family=Noto+Sans+JP:wght@400;700&family=Noto+Sans+TC:wght@400;700&family=Noto+Sans+Devanagari:wght@400;700&display=swap');
        
        body {
            font-family: 'Zen Kaku Gothic New', sans-serif;
            -webkit-font-smoothing: antialiased;
            overscroll-behavior: none;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Pop Background Patterns */
        .bg-pop-light {
            background-color: #f8fafc;
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        .bg-pop-dark {
            background-color: #0f172a;
            background-image: radial-gradient(#334155 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Custom Scrollbar - Made touch friendly */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .dark ::-webkit-scrollbar-thumb { background: #475569; }
        
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }

        .h-safe-screen {
            height: 100vh;
            height: 100dvh;
        }
        
        .font-pop { font-family: 'Zen Maru Gothic', sans-serif; }
    </style>
</head>
<body class="bg-pop-light dark:bg-pop-dark text-slate-800 dark:text-slate-100 transition-colors duration-300">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- Translations (Updated with Duration Guide) ---
        const TRANSLATIONS = {
            ja: {
                title: 'Simple Memories',
                tabPhoto: '写真', tabAudio: '音楽', tabTheater: 'シアター',
                addPhoto: '写真を追加', addMusic: '音楽を追加',
                dragDrop: 'ドラッグ＆ドロップ可',
                autoFitTitle: 'オートフィット',
                autoFitDesc: '音楽の長さに合わせて、全ての写真の表示時間を自動で調整します。',
                run: '実行する',
                secPerPhoto: '1枚の秒数',
                autoFitLocked: '※音楽入りは自動調整固定になります',
                motion: '動き (Motion)', transition: '切り替え (Transition)', filter: 'フィルター',
                exportVideo: '動画を書き出す (MP4)',
                stopExport: '書き出し停止',
                recStopTitle: '書き出しを停止しますか？',
                recStopMsg: '途中までの動画が保存されます。',
                recWarning: '※書き出し中はページを切り替えないでください',
                stop: '停止する', cancel: 'キャンセル',
                totalTime: '総時間', photos: '枚数', size: 'サイズ',
                noPhotos: '写真を追加してください',
                rec: 'REC',
                dlSuccess: '動画を保存しました',
                errNoBrowser: '録画非対応ブラウザです',
                errNoData: '写真と音楽が必要です',
                errNoPhoto: '写真がありません',
                ver: 'ver 4.7 (Aurora Edition)',
                wakeLockActive: 'スリープ防止機能: ON',
                guideTitle: '録画時間の目安',
                guideMobile: '推奨 5-10分 (限界15分)',
                guidePC: '推奨 20-30分 (限界60分)',
                guideTip: 'Pro Tip: 長編は5分ごとに分割して保存し、後で結合するのが安全です。'
            },
            en: {
                title: 'Simple Memories',
                tabPhoto: 'Photos', tabAudio: 'Audio', tabTheater: 'Theater',
                addPhoto: 'Add Photos', addMusic: 'Add Audio',
                dragDrop: 'Drag & Drop available',
                autoFitTitle: 'Auto Fit',
                autoFitDesc: 'Automatically adjusts photo duration to match music length.',
                run: 'Execute',
                secPerPhoto: 'Sec per Photo',
                autoFitLocked: '* Locked to music duration',
                motion: 'Motion', transition: 'Transition', filter: 'Filter',
                exportVideo: 'Export Video (MP4)',
                stopExport: 'Stop Export',
                recStopTitle: 'Stop exporting?',
                recStopMsg: 'The video up to this point will be saved.',
                recWarning: '* Do not switch tabs during export',
                stop: 'Stop', cancel: 'Cancel',
                totalTime: 'Total Time', photos: 'Photos', size: 'Size',
                noPhotos: 'Please add photos',
                rec: 'REC',
                dlSuccess: 'Video saved successfully',
                errNoBrowser: 'Browser not supported',
                errNoData: 'Photos and Music required',
                errNoPhoto: 'No photos added',
                ver: 'ver 4.7 (Aurora Edition)',
                wakeLockActive: 'Wake Lock: ON',
                guideTitle: 'Recording Duration',
                guideMobile: 'Rec 5-10m (Limit 15m)',
                guidePC: 'Rec 20-30m (Limit 60m)',
                guideTip: 'Pro Tip: For long videos, save every 5 mins and merge later.'
            },
            es: {
                title: 'Simple Memories',
                tabPhoto: 'Fotos', tabAudio: 'Audio', tabTheater: 'Cine',
                addPhoto: 'Añadir Fotos', addMusic: 'Añadir Audio',
                dragDrop: 'Arrastrar y soltar',
                autoFitTitle: 'Ajuste Auto',
                autoFitDesc: 'Ajusta automáticamente la duración de las fotos a la música.',
                run: 'Ejecutar',
                secPerPhoto: 'Seg. por Foto',
                autoFitLocked: '* Bloqueado a la duración de la música',
                motion: 'Movimiento', transition: 'Transición', filter: 'Filtro',
                exportVideo: 'Exportar Video (MP4)',
                stopExport: 'Detener',
                recStopTitle: '¿Detener exportación?',
                recStopMsg: 'Se guardará el video hasta este punto.',
                recWarning: '* No cambies de pestaña al exportar',
                stop: 'Detener', cancel: 'Cancelar',
                totalTime: 'Tiempo Total', photos: 'Fotos', size: 'Tamaño',
                noPhotos: 'Añade fotos por favor',
                rec: 'REC',
                dlSuccess: 'Video guardado',
                errNoBrowser: 'Navegador no soportado',
                errNoData: 'Se requieren fotos y música',
                errNoPhoto: 'No hay fotos',
                ver: 'ver 4.7 (Aurora Edition)',
                wakeLockActive: 'Wake Lock: ON',
                guideTitle: 'Guía de Duración',
                guideMobile: 'Rec 5-10m (Límite 15m)',
                guidePC: 'Rec 20-30m (Límite 60m)',
                guideTip: 'Consejo: Para videos largos, guarda cada 5 min y une después.'
            },
            tw: {
                title: 'Simple Memories',
                tabPhoto: '照片', tabAudio: '音樂', tabTheater: '影院',
                addPhoto: '新增照片', addMusic: '新增音樂',
                dragDrop: '可拖放上傳',
                autoFitTitle: '自動適配',
                autoFitDesc: '根據音樂長度自動調整照片顯示時間。',
                run: '執行',
                secPerPhoto: '每張秒數',
                autoFitLocked: '* 已鎖定為音樂長度',
                motion: '動態效果', transition: '轉場效果', filter: '濾鏡',
                exportVideo: '導出影片 (MP4)',
                stopExport: '停止導出',
                recStopTitle: '確定停止導出？',
                recStopMsg: '將保存目前的進度。',
                recWarning: '* 導出時請勿切換頁面',
                stop: '停止', cancel: '取消',
                totalTime: '總時間', photos: '張數', size: '尺寸',
                noPhotos: '請新增照片',
                rec: 'REC',
                dlSuccess: '影片已保存',
                errNoBrowser: '瀏覽器不支援',
                errNoData: '需要照片和音樂',
                errNoPhoto: '沒有照片',
                ver: 'ver 4.7 (Aurora Edition)',
                wakeLockActive: '喚醒鎖定: ON',
                guideTitle: '錄製時間指南',
                guideMobile: '建議 5-10分 (極限15分)',
                guidePC: '建議 20-30分 (極限60分)',
                guideTip: '提示: 長影片請分段保存後再合併。'
            },
            hi: {
                title: 'Simple Memories',
                tabPhoto: 'तस्वीरें', tabAudio: 'ऑडियो', tabTheater: 'थिएटर',
                addPhoto: 'तस्वीरें जोड़ें', addMusic: 'संगीत जोड़ें',
                dragDrop: 'ड्रैग एंड ड्रॉप उपलब्ध',
                autoFitTitle: 'ऑटो फिट',
                autoFitDesc: 'संगीत की लंबाई के अनुसार फोटो का समय समायोजित करें।',
                run: 'चलाएं',
                secPerPhoto: 'प्रति फोटो सेकंड',
                autoFitLocked: '* संगीत की अवधि के लिए लॉक किया गया',
                motion: 'गति (Motion)', transition: 'परिवर्तन (Transition)', filter: 'फ़िल्टर',
                exportVideo: 'वीडियो निर्यात करें (MP4)',
                stopExport: 'रोकें',
                recStopTitle: 'निर्यात रोकें?',
                recStopMsg: 'अब तक का वीडियो सहेजा जाएगा।',
                recWarning: '* निर्यात के दौरान टैब न बदलें',
                stop: 'रोकें', cancel: 'रद्द करें',
                totalTime: 'कुल समय', photos: 'तस्वीरें', size: 'आकार',
                noPhotos: 'कृपया तस्वीरें जोड़ें',
                rec: 'REC',
                dlSuccess: 'वीडियो सहेजा गया',
                errNoBrowser: 'ब्राउज़र समर्थित नहीं है',
                errNoData: 'तस्वीरें और संगीत आवश्यक हैं',
                errNoPhoto: 'कोई तस्वीरें नहीं',
                ver: 'ver 4.7 (Aurora Edition)',
                wakeLockActive: 'Wake Lock: ON',
                guideTitle: 'रिकॉर्डिंग समय',
                guideMobile: '5-10 मिनट (सीमा 15 मिनट)',
                guidePC: '20-30 मिनट (सीमा 60 मिनट)',
                guideTip: 'सुझाव: लंबे वीडियो को भागों में सहेजें।'
            }
        };

        const LANG_OPTIONS = [
            { code: 'ja', label: '日本語' },
            { code: 'en', label: 'English' },
            { code: 'es', label: 'Español' },
            { code: 'tw', label: '繁體中文' },
            { code: 'hi', label: 'हिन्दी' },
        ];

        // --- Constants & Config ---
        const APP_CONFIG = {
            DEFAULT_DURATION: 3.0,
            TRANSITION_DURATION: 1.0,
            BITRATE: 5000000,
        };

        const FILTERS = {
            none: { name: 'None (Standard)', filter: 'none' },
            sepia: { name: 'Sepia (Memories)', filter: 'sepia(0.6) contrast(1.1) brightness(0.9)' },
            mono: { name: 'Mono (Classic)', filter: 'grayscale(100%) contrast(1.2)' },
            pop: { name: 'Pop (Vibrant)', filter: 'saturate(1.4) brightness(1.1)' },
            retro: { name: 'Retro (Film)', filter: 'contrast(0.8) brightness(1.1) sepia(0.3)' },
        };

        const TRANSITIONS = {
            fade: { name: 'Fade', type: 'fade' },
            slide: { name: 'Slide', type: 'slide' },
            none: { name: 'Cut', type: 'none' },
        };

        const MOTIONS = {
            kenburns: { name: 'Ken Burns', type: 'kenburns' },
            none: { name: 'Static', type: 'none' },
        };

        const ASPECT_RATIOS = {
            '16:9': { w: 1920, h: 1080, label: 'YouTube/TV' },
            '1:1': { w: 1080, h: 1080, label: 'Instagram' },
            '9:16': { w: 1080, h: 1920, label: 'TikTok/Shorts' },
        };

        // --- Icons ---
        const Icon = ({ name, size = 24, className = "" }) => {
            const ref = useRef(null);
            useEffect(() => {
                if (!ref.current) return;
                const i = document.createElement('i');
                i.setAttribute('data-lucide', name);
                ref.current.innerHTML = '';
                ref.current.appendChild(i);
                lucide.createIcons({
                    root: ref.current, nameAttr: 'data-lucide',
                    attrs: { width: size, height: size, class: className }
                });
            }, [name, size, className]);
            return <span ref={ref} style={{ display: 'inline-flex', alignItems: 'center', justifyContent: 'center' }} />;
        };

        // --- Audio Controller ---
        class AudioController {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.destination = this.ctx.createMediaStreamDestination();
                this.sources = [];
            }
            async decodeFile(file) {
                const arrayBuffer = await file.arrayBuffer();
                return await this.ctx.decodeAudioData(arrayBuffer);
            }
            play(buffer, time = 0, loop = false) {
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                source.loop = loop;
                source.connect(this.ctx.destination); 
                source.connect(this.destination);
                source.start(time);
                this.sources.push(source);
                return source;
            }
            stopAll() { this.sources.forEach(s => { try { s.stop(); } catch(e){} }); this.sources = []; }
            getStream() { return this.destination.stream; }
            resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
        }

        // --- Components ---
        const Toast = ({ message, type, onClose }) => {
            useEffect(() => { const t = setTimeout(onClose, 3000); return () => clearTimeout(t); }, []);
            const bg = { success: 'bg-green-500', error: 'bg-red-500', info: 'bg-indigo-500', wake: 'bg-amber-500' };
            return (
                <div className={`fixed top-4 right-4 ${bg[type] || 'bg-gray-800'} text-white px-6 py-3 rounded-xl shadow-xl z-[100] flex items-center gap-3 animate-fade-in font-bold`}>
                    <span>{message}</span>
                </div>
            );
        };

        const ConfirmModal = ({ isOpen, title, message, onConfirm, onCancel, texts }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center modal-overlay p-4">
                    <div className="bg-white dark:bg-slate-800 rounded-2xl shadow-2xl p-6 max-w-sm w-full animate-bounce-in border border-gray-100 dark:border-slate-700">
                        <h3 className="text-lg font-bold text-slate-800 dark:text-white mb-2 font-pop">{title}</h3>
                        <p className="text-slate-600 dark:text-slate-300 mb-6 text-sm">{message}</p>
                        <div className="flex gap-3 justify-end">
                            <button onClick={onCancel} className="px-4 py-2 text-slate-600 dark:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-lg font-bold text-sm">{texts.cancel}</button>
                            <button onClick={onConfirm} className="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded-lg font-bold text-sm shadow-lg shadow-red-500/30">{texts.stop}</button>
                        </div>
                    </div>
                </div>
            );
        };

        // Restored FileInfoModal
        const FileInfoModal = ({ isOpen, onClose }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[70] flex items-center justify-center modal-overlay p-4" onClick={onClose}>
                    <div className="bg-white dark:bg-slate-800 rounded-2xl shadow-2xl p-6 max-w-sm w-full animate-bounce-in relative" onClick={e => e.stopPropagation()}>
                        <button onClick={onClose} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600 dark:hover:text-white"><Icon name="x" size={20}/></button>
                        <h3 className="text-lg font-bold text-slate-800 dark:text-white mb-4 font-pop flex items-center gap-2">
                            <Icon name="file-question" className="text-indigo-500"/> Supported Files
                        </h3>
                        <div className="space-y-4">
                            <div>
                                <h4 className="text-xs font-bold text-indigo-500 uppercase mb-2">Images</h4>
                                <div className="flex flex-wrap gap-2">
                                    {['JPG', 'PNG', 'WEBP', 'GIF', 'SVG'].map(ext => (
                                        <span key={ext} className="px-2 py-1 bg-indigo-5 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300 text-xs rounded-md font-mono border border-indigo-100 dark:border-indigo-800">{ext}</span>
                                    ))}
                                </div>
                            </div>
                            <div>
                                <h4 className="text-xs font-bold text-purple-500 uppercase mb-2">Audio</h4>
                                <div className="flex flex-wrap gap-2">
                                    {['MP3', 'WAV', 'AAC', 'M4A', 'OGG'].map(ext => (
                                        <span key={ext} className="px-2 py-1 bg-purple-50 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300 text-xs rounded-md font-mono border border-purple-100 dark:border-purple-800">{ext}</span>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // New Duration Guide Modal
        const RecDurationModal = ({ isOpen, onClose, texts }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[70] flex items-center justify-center modal-overlay p-4" onClick={onClose}>
                    <div className="bg-white dark:bg-slate-800 rounded-2xl shadow-2xl p-6 max-w-sm w-full animate-bounce-in relative border border-indigo-100 dark:border-indigo-900" onClick={e => e.stopPropagation()}>
                        <button onClick={onClose} className="absolute top-4 right-4 text-slate-400 hover:text-slate-600 dark:hover:text-white"><Icon name="x" size={20}/></button>
                        <h3 className="text-lg font-bold text-slate-800 dark:text-white mb-4 font-pop flex items-center gap-2">
                            <Icon name="clock" className="text-indigo-500"/> {texts.guideTitle}
                        </h3>
                        <div className="space-y-4">
                            <div className="p-3 bg-indigo-50 dark:bg-indigo-900/20 rounded-xl border border-indigo-100 dark:border-indigo-800">
                                <h4 className="text-xs font-bold text-indigo-600 dark:text-indigo-300 uppercase mb-1 flex items-center gap-1"><Icon name="smartphone" size={14}/> Mobile / iPhone</h4>
                                <p className="text-lg font-bold text-slate-800 dark:text-white">{texts.guideMobile}</p>
                            </div>
                            <div className="p-3 bg-slate-50 dark:bg-slate-700/30 rounded-xl border border-gray-100 dark:border-slate-700">
                                <h4 className="text-xs font-bold text-slate-600 dark:text-slate-300 uppercase mb-1 flex items-center gap-1"><Icon name="monitor" size={14}/> PC / Mac</h4>
                                <p className="text-lg font-bold text-slate-800 dark:text-white">{texts.guidePC}</p>
                            </div>
                            <div className="flex items-start gap-2 text-xs text-slate-500 dark:text-slate-400 leading-relaxed bg-white dark:bg-slate-800 p-2 rounded-lg">
                                <Icon name="lightbulb" size={16} className="text-yellow-500 shrink-0 mt-0.5" />
                                <span>{texts.guideTip}</span>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Main App ---
        const App = () => {
            const [photos, setPhotos] = useState([]);
            const [music, setMusic] = useState([]);
            const [activeTab, setActiveTab] = useState('photos');
            const [settings, setSettings] = useState({
                durationPerPhoto: 4,
                transitionDuration: 1.0,
                motion: 'kenburns',
                transition: 'fade',
                filter: 'none',
                aspectRatio: '16:9'
            });
            const [isRecording, setIsRecording] = useState(false);
            const [previewTime, setPreviewTime] = useState(0);
            const [isPlaying, setIsPlaying] = useState(false);
            const [toasts, setToasts] = useState([]);
            const [showStopConfirm, setShowStopConfirm] = useState(false);
            const [lang, setLang] = useState('ja');
            const [darkMode, setDarkMode] = useState(false);
            const [showFileInfo, setShowFileInfo] = useState(false); // Restored State
            const [showDurationGuide, setShowDurationGuide] = useState(false); // New State for Guide

            const canvasRef = useRef(null);
            const audioController = useRef(null);
            const requestRef = useRef();
            const startTimeRef = useRef(0);
            const mediaRecorderRef = useRef(null);
            const isPlayingRef = useRef(false);
            const isRecordingRef = useRef(false);
            const wakeLockRef = useRef(null); // Wake Lock Reference

            const t = TRANSLATIONS[lang] || TRANSLATIONS['ja'];
            const aspectConfig = ASPECT_RATIOS[settings.aspectRatio];
            const totalDuration = useMemo(() => photos.length > 0 ? photos.length * settings.durationPerPhoto : 0, [photos.length, settings.durationPerPhoto]);

            useEffect(() => {
                audioController.current = new AudioController();
                return () => { 
                    if(audioController.current) audioController.current.stopAll(); 
                    cancelAnimationFrame(requestRef.current);
                    releaseWakeLock(); // Safety cleanup
                };
            }, []);

            useEffect(() => {
                if (darkMode) document.documentElement.classList.add('dark');
                else document.documentElement.classList.remove('dark');
            }, [darkMode]);

            // Auto-fit duration logic
            useEffect(() => {
                if (music.length > 0 && photos.length > 0) {
                    const totalMusicDuration = music.reduce((acc, m) => acc + m.duration, 0);
                    const newDuration = totalMusicDuration / photos.length;
                    if (Math.abs(settings.durationPerPhoto - newDuration) > 0.05) {
                        setSettings(prev => ({ ...prev, durationPerPhoto: parseFloat(newDuration.toFixed(1)) }));
                    }
                }
            }, [music, photos.length, settings.durationPerPhoto]);

            // --- Wake Lock Functions ---
            const requestWakeLock = async () => {
                try {
                    if ('wakeLock' in navigator) {
                        wakeLockRef.current = await navigator.wakeLock.request('screen');
                        addToast(t.wakeLockActive, 'wake');
                    }
                } catch (err) {
                    console.log('Wake Lock Error:', err);
                }
            };

            const releaseWakeLock = async () => {
                if (wakeLockRef.current) {
                    await wakeLockRef.current.release();
                    wakeLockRef.current = null;
                }
            };

            const addToast = (msg, type = 'info') => {
                const id = Date.now();
                setToasts(prev => [...prev, { id, msg, type }]);
            };
            const removeToast = (id) => setToasts(prev => prev.filter(t => t.id !== id));

            const handlePhotoUpload = (e) => {
                const files = Array.from(e.target.files);
                const newPhotos = files.map(file => ({
                    id: crypto.randomUUID(), file, url: URL.createObjectURL(file), rotation: 0, motion: { type: ['zoomIn','zoomOut','panRight','panLeft'][Math.floor(Math.random()*4)] }
                }));
                setPhotos(prev => [...prev, ...newPhotos]);
                addToast(`${files.length} ${t.photos}`, 'success');
            };

            const handleMusicUpload = async (e) => {
                const files = Array.from(e.target.files);
                addToast('Loading...', 'info');
                for (const file of files) {
                    try {
                        const buffer = await audioController.current.decodeFile(file);
                        setMusic(prev => [...prev, { id: crypto.randomUUID(), name: file.name, buffer, duration: buffer.duration }]);
                    } catch (err) { addToast('Error', 'error'); }
                }
                addToast(t.tabAudio, 'success');
            };

            const fitToMusic = () => {
                if (music.length === 0 || photos.length === 0) return addToast(t.errNoData, 'error');
                const totalMusic = music.reduce((acc, m) => acc + m.duration, 0);
                const newDur = totalMusic / photos.length;
                setSettings(prev => ({ ...prev, durationPerPhoto: parseFloat(newDur.toFixed(1)) }));
                addToast(`1 = ${newDur.toFixed(1)}s`, 'success');
            };

            // Canvas Drawing Logic
            const renderFrame = (ctx, time) => {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, aspectConfig.w, aspectConfig.h);
                if (photos.length === 0) return;

                const currentTime = time % Math.max(0.1, totalDuration);
                const pIndex = Math.floor(currentTime / settings.durationPerPhoto);
                const photoTime = currentTime % settings.durationPerPhoto;
                const currentPhoto = photos[pIndex];
                const nextPhoto = photos[(pIndex + 1) % photos.length];
                
                if (currentPhoto) drawPhoto(ctx, currentPhoto, photoTime, 1.0, false);

                const tType = settings.transition;
                const tDur = settings.transitionDuration;

                if (tType !== 'none' && tDur > 0 && photoTime > (settings.durationPerPhoto - tDur)) {
                    const tProgress = (photoTime - (settings.durationPerPhoto - tDur)) / tDur;
                    if (nextPhoto && pIndex < photos.length - 1) {
                        if (tType === 'fade') drawPhoto(ctx, nextPhoto, 0, tProgress, false);
                        else if (tType === 'slide') {
                            ctx.save(); ctx.translate((1 - tProgress) * aspectConfig.w, 0);
                            drawPhoto(ctx, nextPhoto, 0, 1.0, false); ctx.restore();
                        }
                    } else if (pIndex === photos.length - 1 && isRecording) {
                        ctx.fillStyle = `rgba(0,0,0,${tProgress})`; ctx.fillRect(0, 0, aspectConfig.w, aspectConfig.h);
                    }
                }
            };

            const drawPhoto = (ctx, photoData, timeInPhoto, opacity, isBg) => {
                if (!photoData.imgElement) {
                    const img = new Image(); img.src = photoData.url; photoData.imgElement = img;
                }
                const img = photoData.imgElement;
                if (!img.complete) return;

                ctx.save();
                ctx.globalAlpha = opacity;
                if (!isBg) ctx.filter = FILTERS[settings.filter].filter;

                const cw = aspectConfig.w; const ch = aspectConfig.h;
                const iw = img.naturalWidth; const ih = img.naturalHeight;
                const scale = Math.max(cw / iw, ch / ih);
                const scaledW = iw * scale; const scaledH = ih * scale;
                const dx = (cw - scaledW) / 2; const dy = (ch - scaledH) / 2;

                if (settings.motion === 'kenburns') {
                    const p = timeInPhoto / settings.durationPerPhoto;
                    const { type } = photoData.motion;
                    const maxScale = 1.15;
                    let s = 1.0, tx = 0, ty = 0;
                    ctx.translate(cw / 2, ch / 2);
                    if (type === 'zoomIn') s = 1.0 + (maxScale - 1.0) * p;
                    else if (type === 'zoomOut') s = maxScale - (maxScale - 1.0) * p;
                    else if (type === 'panRight') { s = maxScale; tx = (cw * 0.05) * (2 * p - 1); }
                    else if (type === 'panLeft') { s = maxScale; tx = -(cw * 0.05) * (2 * p - 1); }
                    ctx.scale(s, s); ctx.translate(tx, ty);
                    ctx.rotate((photoData.rotation * Math.PI) / 180);
                    ctx.translate(-cw / 2, -ch / 2);
                } else {
                    ctx.translate(cw / 2, ch / 2);
                    ctx.rotate((photoData.rotation * Math.PI) / 180);
                    ctx.translate(-cw / 2, -ch / 2);
                }
                ctx.drawImage(img, dx, dy, scaledW, scaledH);
                ctx.restore();
            };

            const animate = (time) => {
                if (!canvasRef.current || (!isPlayingRef.current && !isRecordingRef.current)) return;
                const deltaTime = (time - startTimeRef.current) / 1000;
                setPreviewTime(deltaTime);
                const ctx = canvasRef.current.getContext('2d');
                renderFrame(ctx, deltaTime);
                if (deltaTime >= totalDuration) {
                    if (isRecordingRef.current) finishRecording();
                    else { startTimeRef.current = time; audioController.current.stopAll(); playMusicFrom(0); }
                } 
                requestRef.current = requestAnimationFrame(animate);
            };

            const playMusicFrom = (startTime) => {
                let currentTime = 0;
                music.forEach(m => {
                    audioController.current.play(m.buffer, audioController.current.ctx.currentTime + currentTime - startTime);
                    currentTime += m.duration;
                });
            }

            const togglePreview = () => {
                if (photos.length === 0) return;
                if (isPlayingRef.current) {
                    setIsPlaying(false); isPlayingRef.current = false;
                    audioController.current.stopAll(); cancelAnimationFrame(requestRef.current);
                } else {
                    audioController.current.resume();
                    setIsPlaying(true); isPlayingRef.current = true;
                    setPreviewTime(0); startTimeRef.current = performance.now();
                    playMusicFrom(0); requestRef.current = requestAnimationFrame(animate);
                }
            };

            const startRecording = async () => {
                if (photos.length === 0) return addToast(t.errNoPhoto, 'error');
                if (isPlayingRef.current) { audioController.current.stopAll(); cancelAnimationFrame(requestRef.current); setIsPlaying(false); isPlayingRef.current = false; }
                
                // Activate Wake Lock
                await requestWakeLock();

                setIsRecording(true); isRecordingRef.current = true;
                setIsPlaying(true); isPlayingRef.current = true;
                setPreviewTime(0);
                
                const canvas = canvasRef.current;
                const canvasStream = canvas.captureStream(30);
                const audioStream = audioController.current.getStream();
                const combinedStream = new MediaStream([...canvasStream.getVideoTracks(), ...audioStream.getAudioTracks()]);

                const mimeTypes = ['video/mp4;codecs=avc1.42E01E,mp4a.40.2', 'video/mp4', 'video/webm;codecs=h264', 'video/webm'];
                const selectedMime = mimeTypes.find(type => MediaRecorder.isTypeSupported(type)) || '';
                
                if (!selectedMime) {
                    setIsRecording(false); isRecordingRef.current = false;
                    releaseWakeLock();
                    return addToast(t.errNoBrowser, 'error');
                }

                const recorder = new MediaRecorder(combinedStream, { mimeType: selectedMime, videoBitsPerSecond: APP_CONFIG.BITRATE });
                const chunks = [];
                recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: selectedMime });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `SimpleMemories_${Date.now()}.${selectedMime.includes('mp4') ? 'mp4' : 'webm'}`;
                    a.click();
                    
                    setIsRecording(false); isRecordingRef.current = false;
                    setIsPlaying(false); isPlayingRef.current = false;
                    audioController.current.stopAll(); cancelAnimationFrame(requestRef.current);
                    
                    releaseWakeLock(); // Release lock
                    addToast(t.dlSuccess, 'success');
                };
                mediaRecorderRef.current = recorder;
                recorder.start();
                audioController.current.resume(); playMusicFrom(0);
                startTimeRef.current = performance.now(); requestRef.current = requestAnimationFrame(animate);
            };

            const confirmStopRecording = () => { if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') setShowStopConfirm(true); };
            const executeStopRecording = () => { setShowStopConfirm(false); if (mediaRecorderRef.current) mediaRecorderRef.current.stop(); addToast(t.recStopMsg, 'info'); };
            const finishRecording = () => { if (mediaRecorderRef.current) mediaRecorderRef.current.stop(); };

            const removePhoto = (id) => setPhotos(prev => prev.filter(p => p.id !== id));
            const rotatePhoto = (id) => setPhotos(prev => prev.map(p => p.id === id ? { ...p, rotation: (p.rotation + 90) % 360 } : p));
            const movePhoto = (idx, dir) => {
                const newP = [...photos];
                if (dir === 'left' && idx > 0) [newP[idx-1], newP[idx]] = [newP[idx], newP[idx-1]];
                else if (dir === 'right' && idx < newP.length-1) [newP[idx+1], newP[idx]] = [newP[idx], newP[idx+1]];
                setPhotos(newP);
            };

            const moveMusic = (idx, dir) => {
                const newM = [...music];
                if (dir === 'up' && idx > 0) [newM[idx-1], newM[idx]] = [newM[idx], newM[idx-1]];
                else if (dir === 'down' && idx < newM.length - 1) [newM[idx+1], newM[idx]] = [newM[idx], newM[idx+1]];
                setMusic(newM);
            };

            return (
                <div className="h-safe-screen flex flex-col max-w-7xl mx-auto shadow-2xl overflow-hidden font-sans transition-all duration-300">
                    {/* Header */}
                    <header className="bg-white/95 dark:bg-slate-900/95 backdrop-blur-md border-b border-gray-200 dark:border-slate-700 px-4 md:px-6 py-3 flex justify-between items-center z-20 shrink-0 transition-colors">
                        <div className="flex items-center gap-2">
                            <div className="bg-indigo-600 text-white p-2 rounded-xl shadow-lg shadow-indigo-500/30 transform hover:scale-110 transition"><Icon name="film" size={24} /></div>
                            <h1 className="text-xl md:text-2xl font-bold text-slate-800 dark:text-white font-pop tracking-tight">Simple Memories</h1>
                        </div>
                        
                        <div className="flex items-center gap-2 md:gap-4">
                            <div className="relative group">
                                <select 
                                    value={lang} onChange={e => setLang(e.target.value)}
                                    className="appearance-none bg-gray-100 dark:bg-slate-800 border border-gray-200 dark:border-slate-700 text-slate-700 dark:text-slate-200 py-1.5 pl-3 pr-8 rounded-lg text-sm font-bold focus:outline-none focus:ring-2 focus:ring-indigo-500 cursor-pointer"
                                >
                                    {LANG_OPTIONS.map(opt => <option key={opt.code} value={opt.code}>{opt.label}</option>)}
                                </select>
                                <div className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none text-gray-400"><Icon name="globe" size={14} /></div>
                            </div>
                            
                            {/* Restored Info Button */}
                            <button onClick={() => setShowFileInfo(true)} className="p-2 text-slate-500 hover:text-indigo-600 dark:text-slate-400 dark:hover:text-indigo-400 transition rounded-full hover:bg-gray-100 dark:hover:bg-slate-800">
                                <Icon name="info" size={20} />
                            </button>

                            {/* New Duration Guide Button */}
                            <button onClick={() => setShowDurationGuide(true)} className="p-2 text-slate-500 hover:text-indigo-600 dark:text-slate-400 dark:hover:text-indigo-400 transition rounded-full hover:bg-gray-100 dark:hover:bg-slate-800">
                                <Icon name="clock" size={20} />
                            </button>

                            <button onClick={() => setDarkMode(!darkMode)} className="p-2 text-slate-500 hover:text-yellow-500 dark:text-slate-400 dark:hover:text-yellow-400 transition rounded-full hover:bg-gray-100 dark:hover:bg-slate-800">
                                <Icon name={darkMode ? "sun" : "moon"} size={20} />
                            </button>
                        </div>
                    </header>

                    <main className="flex-1 flex flex-col md:flex-row overflow-hidden relative">
                        {/* PREVIEW AREA (45vh on mobile) */}
                        <div className="order-1 md:order-2 bg-slate-900 flex flex-col items-center justify-center p-4 md:p-8 relative h-[45vh] md:h-auto md:flex-1 shrink-0 overflow-hidden border-b md:border-b-0 md:border-l border-slate-700">
                            <div className="absolute inset-0 opacity-10" style={{backgroundImage: 'radial-gradient(#fff 1px, transparent 1px)', backgroundSize: '30px 30px'}}></div>

                            {!isRecording && (
                                <div className="absolute top-4 right-4 bg-black/60 backdrop-blur-md rounded-lg p-1 flex gap-1 z-10 border border-white/10 shadow-lg">
                                    {Object.entries(ASPECT_RATIOS).map(([r, conf]) => (
                                        <button key={r} onClick={() => setSettings({...settings, aspectRatio: r})} title={conf.label}
                                            className={`px-3 py-1 text-xs font-bold rounded transition ${settings.aspectRatio === r ? 'bg-white text-black' : 'text-gray-400 hover:text-white'}`}>
                                            {r}
                                        </button>
                                    ))}
                                </div>
                            )}

                            <div className="relative shadow-2xl transition-all duration-500 group" style={{
                                aspectRatio: `${aspectConfig.w}/${aspectConfig.h}`,
                                maxHeight: '100%', maxWidth: '100%', width: aspectConfig.h > aspectConfig.w ? 'auto' : '100%'
                            }}>
                                <canvas ref={canvasRef} width={aspectConfig.w} height={aspectConfig.h} className="w-full h-full object-contain bg-black rounded-lg shadow-2xl ring-1 ring-white/10" />
                                {photos.length === 0 && (
                                    <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-500">
                                        <Icon name="image" size={48} className="mb-2 opacity-30"/>
                                        <p className="font-bold opacity-50">{t.noPhotos}</p>
                                    </div>
                                )}
                                {isRecording && (
                                    <div className="absolute top-4 left-4 flex items-center gap-2 bg-red-600/90 text-white px-4 py-1.5 rounded-full text-xs font-bold backdrop-blur-sm z-10 border border-white/20 shadow-lg animate-pulse">
                                        <div className="w-2 h-2 bg-white rounded-full"></div> {t.rec}
                                    </div>
                                )}
                            </div>

                            <div className="mt-4 md:mt-8 flex items-center gap-6 bg-slate-800/90 backdrop-blur-md px-6 py-2 md:px-8 md:py-3 rounded-full border border-white/10 shadow-2xl scale-90 md:scale-100 z-10 hover:bg-slate-800 transition">
                                <button onClick={togglePreview} disabled={isRecording} className="p-3 md:p-4 bg-white rounded-full hover:scale-110 active:scale-95 transition text-slate-900 shadow-lg disabled:opacity-50 disabled:scale-100">
                                    <Icon name={isPlaying ? "pause" : "play"} fill="currentColor" size={20} />
                                </button>
                                <div className="flex flex-col">
                                    <div className="text-white font-mono text-lg md:text-xl font-bold tracking-widest tabular-nums text-shadow">
                                        {previewTime.toFixed(1)}<span className="text-sm text-slate-400 ml-1">s</span>
                                    </div>
                                    <div className="text-xs text-slate-500 font-mono text-right border-t border-slate-600 pt-1">
                                        / {totalDuration.toFixed(1)}s
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* TOOLS AREA - Mobile Optimized Scroll */}
                        <div className="order-2 md:order-1 w-full md:w-1/3 lg:w-1/4 bg-white/90 dark:bg-slate-900/90 flex flex-col flex-1 min-h-0 z-10 backdrop-blur-sm transition-colors relative">
                            {/* Fixed Tab Header */}
                            <div className="flex border-b border-gray-200 dark:border-slate-700 shrink-0 bg-white/95 dark:bg-slate-900/95 backdrop-blur z-20 shadow-sm">
                                {['photos', 'audio', 'export'].map(tab => (
                                    <button key={tab} onClick={() => !isRecording && setActiveTab(tab)} 
                                        className={`flex-1 py-4 text-sm font-bold flex justify-center items-center gap-2 transition relative overflow-hidden ${activeTab === tab ? 'text-indigo-600 dark:text-indigo-400 bg-indigo-50/50 dark:bg-indigo-900/20' : 'text-gray-500 dark:text-slate-400 hover:bg-gray-50 dark:hover:bg-slate-800'} ${isRecording ? 'opacity-50 cursor-not-allowed' : ''}`}>
                                        <Icon name={tab === 'photos' ? 'image' : tab === 'audio' ? 'music' : 'settings-2'} size={18} />
                                        <span className="hidden sm:inline font-pop">{tab === 'photos' ? t.tabPhoto : tab === 'audio' ? t.tabAudio : t.tabTheater}</span>
                                        {activeTab === tab && <div className="absolute bottom-0 left-0 right-0 h-1 bg-indigo-500 rounded-t-full mx-4"></div>}
                                    </button>
                                ))}
                            </div>

                            {/* Scrollable Content Area with Infinite Spacer */}
                            <div className="flex-1 overflow-y-auto p-4 space-y-4 overscroll-contain">
                                {activeTab === 'photos' && (
                                    <div className="space-y-4 animate-fade-in">
                                        <label className="block w-full border-2 border-dashed border-indigo-200 dark:border-indigo-800 rounded-2xl p-6 text-center hover:bg-indigo-50 dark:hover:bg-indigo-900/20 transition cursor-pointer group bg-white/50 dark:bg-slate-800/50">
                                            <input type="file" multiple accept="image/*" onChange={handlePhotoUpload} className="hidden" />
                                            <div className="bg-indigo-100 dark:bg-indigo-900 text-indigo-600 dark:text-indigo-300 w-12 h-12 rounded-full flex items-center justify-center mx-auto mb-3 group-hover:scale-110 transition shadow-md"><Icon name="plus" /></div>
                                            <span className="text-sm text-indigo-600 dark:text-indigo-300 font-bold block">{t.addPhoto}</span>
                                        </label>
                                        <div className="grid grid-cols-2 gap-3">
                                            {photos.map((p, i) => (
                                                <div key={p.id} className="relative group aspect-square bg-gray-100 dark:bg-slate-800 rounded-xl overflow-hidden border border-gray-200 dark:border-slate-700 shadow-sm hover:shadow-md transition">
                                                    <img src={p.url} className="w-full h-full object-cover" style={{transform: `rotate(${p.rotation}deg)`}} />
                                                    <div className="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition flex items-center justify-center gap-2 backdrop-blur-[1px]">
                                                        <button onClick={() => rotatePhoto(p.id)} className="p-2 bg-white rounded-full text-slate-700 hover:scale-110 shadow-lg"><Icon name="rotate-cw" size={14} /></button>
                                                        <button onClick={() => removePhoto(p.id)} className="p-2 bg-red-500 rounded-full text-white hover:scale-110 shadow-lg"><Icon name="trash-2" size={14} /></button>
                                                    </div>
                                                    <div className="absolute bottom-1 left-0 right-0 flex justify-between px-1 opacity-0 group-hover:opacity-100 transition">
                                                        <button onClick={() => movePhoto(i, 'left')} disabled={i===0} className="text-white drop-shadow-md disabled:opacity-30 hover:scale-110 transition"><Icon name="arrow-left-circle" size={20}/></button>
                                                        <button onClick={() => movePhoto(i, 'right')} disabled={i===photos.length-1} className="text-white drop-shadow-md disabled:opacity-30 hover:scale-110 transition"><Icon name="arrow-right-circle" size={20}/></button>
                                                    </div>
                                                    <div className="absolute top-1 left-2 bg-black/60 text-white text-[10px] px-2 py-0.5 rounded-full font-bold font-mono">{i + 1}</div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                {activeTab === 'audio' && (
                                    <div className="space-y-6 animate-fade-in">
                                        <div className="bg-gradient-to-br from-indigo-50 to-purple-50 dark:from-indigo-900/30 dark:to-purple-900/30 p-5 rounded-2xl border border-indigo-100 dark:border-indigo-800 shadow-sm">
                                            <h3 className="text-sm font-bold text-indigo-800 dark:text-indigo-200 mb-2 flex items-center gap-2"><Icon name="wand-2" size={16}/> {t.autoFitTitle}</h3>
                                            <p className="text-xs text-indigo-600 dark:text-indigo-300 mb-4 leading-relaxed">{t.autoFitDesc}</p>
                                            <button onClick={fitToMusic} className="w-full py-2.5 bg-indigo-600 hover:bg-indigo-700 text-white rounded-xl text-sm font-bold shadow-md hover:shadow-lg transition transform active:scale-95">{t.run}</button>
                                        </div>
                                        <label className="block w-full border-2 border-dashed border-gray-300 dark:border-slate-600 rounded-2xl p-4 text-center hover:bg-gray-50 dark:hover:bg-slate-800 transition cursor-pointer bg-white/50 dark:bg-slate-800/50">
                                            <input type="file" multiple accept="audio/*" onChange={handleMusicUpload} className="hidden" />
                                            <div className="w-10 h-10 bg-gray-100 dark:bg-slate-700 rounded-full flex items-center justify-center mx-auto mb-2 text-gray-500 dark:text-slate-400"><Icon name="music" /></div>
                                            <span className="text-sm text-gray-600 dark:text-slate-300 font-bold">{t.addMusic}</span>
                                        </label>
                                        <div className="space-y-2">
                                            {music.map((m, i) => (
                                                <div key={m.id} className="flex items-center gap-2 bg-white dark:bg-slate-800 p-2 rounded-xl border border-gray-100 dark:border-slate-700 shadow-sm">
                                                    <div className="flex flex-col gap-0.5">
                                                        <button onClick={() => moveMusic(i, 'up')} disabled={i === 0} className="text-slate-400 hover:text-indigo-500 disabled:opacity-20 transition p-0.5"><Icon name="chevron-up" size={14}/></button>
                                                        <button onClick={() => moveMusic(i, 'down')} disabled={i === music.length - 1} className="text-slate-400 hover:text-indigo-500 disabled:opacity-20 transition p-0.5"><Icon name="chevron-down" size={14}/></button>
                                                    </div>
                                                    <div className="bg-purple-100 dark:bg-purple-900 p-2 rounded-lg text-purple-600 dark:text-purple-300 shrink-0"><Icon name="music-2" size={16} /></div>
                                                    <div className="flex-1 min-w-0">
                                                        <p className="text-sm font-bold text-slate-700 dark:text-slate-200 truncate">{m.name}</p>
                                                        <p className="text-xs text-slate-400 font-mono">{m.duration.toFixed(1)}s</p>
                                                    </div>
                                                    <button onClick={() => setMusic(p => p.filter(x => x.id !== m.id))} className="text-gray-300 hover:text-red-500 dark:text-slate-600 dark:hover:text-red-400 transition p-1"><Icon name="x" size={18} /></button>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                {activeTab === 'export' && (
                                    <div className="space-y-6 animate-fade-in">
                                        <div className="space-y-4">
                                            <div className="bg-white dark:bg-slate-800 p-4 rounded-2xl border border-gray-100 dark:border-slate-700 shadow-sm">
                                                <label className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase flex items-center gap-1 mb-3"><Icon name="move" size={14}/> {t.motion}</label>
                                                <div className="grid grid-cols-2 gap-2">
                                                    {Object.entries(MOTIONS).map(([k, v]) => (
                                                        <button key={k} onClick={() => setSettings({...settings, motion: k})}
                                                            className={`text-xs py-2.5 rounded-lg font-bold transition ${settings.motion === k ? 'bg-indigo-600 text-white shadow-md' : 'bg-gray-50 dark:bg-slate-700 text-slate-600 dark:text-slate-300 hover:bg-gray-100 dark:hover:bg-slate-600'}`}>
                                                            {v.name}
                                                        </button>
                                                    ))}
                                                </div>
                                            </div>

                                            <div className="bg-white dark:bg-slate-800 p-4 rounded-2xl border border-gray-100 dark:border-slate-700 shadow-sm">
                                                <label className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase flex items-center gap-1 mb-3"><Icon name="layers" size={14}/> {t.transition}</label>
                                                <div className="grid grid-cols-3 gap-2">
                                                    {Object.entries(TRANSITIONS).map(([k, v]) => (
                                                        <button key={k} onClick={() => setSettings({...settings, transition: k})}
                                                            className={`text-[10px] py-2.5 rounded-lg font-bold transition ${settings.transition === k ? 'bg-indigo-600 text-white shadow-md' : 'bg-gray-50 dark:bg-slate-700 text-slate-600 dark:text-slate-300 hover:bg-gray-100 dark:hover:bg-slate-600'}`}>
                                                            {v.name}
                                                        </button>
                                                    ))}
                                                </div>
                                                <div className="mt-4 flex items-center gap-3">
                                                    <input type="range" min="0.1" max="2.0" step="0.1" value={settings.transitionDuration} onChange={e => setSettings({...settings, transitionDuration: parseFloat(e.target.value)})} className="flex-1 h-1.5 bg-gray-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-indigo-600"/>
                                                    <span className="text-xs font-mono text-slate-500 dark:text-slate-400 w-8 text-right">{settings.transitionDuration}s</span>
                                                </div>
                                            </div>

                                            <div className="bg-white dark:bg-slate-800 p-4 rounded-2xl border border-gray-100 dark:border-slate-700 shadow-sm">
                                                <label className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase flex items-center gap-1 mb-3"><Icon name="palette" size={14}/> {t.filter}</label>
                                                <select value={settings.filter} onChange={e => setSettings({...settings, filter: e.target.value})} className="w-full p-2.5 border border-gray-200 dark:border-slate-600 rounded-xl text-sm bg-gray-50 dark:bg-slate-700 text-slate-700 dark:text-slate-200 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                                    {Object.entries(FILTERS).map(([k, v]) => <option key={k} value={k}>{v.name}</option>)}
                                                </select>
                                            </div>

                                            <div className="px-1">
                                                <label className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase mb-2 block">{t.secPerPhoto}</label>
                                                <div className={`flex items-center gap-3 bg-white dark:bg-slate-800 p-3 rounded-xl border border-gray-200 dark:border-slate-700 ${music.length > 0 ? 'opacity-70' : ''}`}>
                                                    <input 
                                                        type="range" 
                                                        min="1" max="10" step="0.1" 
                                                        value={settings.durationPerPhoto} 
                                                        onChange={e => setSettings({...settings, durationPerPhoto: parseFloat(e.target.value)})} 
                                                        disabled={music.length > 0}
                                                        className="flex-1 h-2 bg-indigo-100 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-indigo-600 disabled:cursor-not-allowed"
                                                    />
                                                    <span className="text-sm font-mono w-12 text-right text-slate-700 dark:text-slate-200">{settings.durationPerPhoto}s</span>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div className="bg-slate-800 dark:bg-black/40 text-slate-300 p-5 rounded-2xl text-xs space-y-2 font-mono border border-slate-700">
                                            <div className="flex justify-between"><span>{t.totalTime}</span><span className="text-white font-bold">{totalDuration.toFixed(1)}s</span></div>
                                            <div className="flex justify-between"><span>{t.photos}</span><span className="text-white font-bold">{photos.length}</span></div>
                                            <div className="flex justify-between"><span>{t.size}</span><span className="text-white font-bold">{aspectConfig.w}x{aspectConfig.h}</span></div>
                                            <div className="border-t border-slate-700 pt-2 mt-2 text-right text-[10px] opacity-50">{t.ver}</div>
                                        </div>

                                        {!isRecording ? (
                                            <button onClick={startRecording} disabled={photos.length === 0}
                                                className="w-full py-4 rounded-xl font-bold text-base shadow-xl bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 text-white hover:shadow-indigo-500/30 hover:scale-[1.02] transition flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed">
                                                <Icon name="download" /> {t.exportVideo}
                                            </button>
                                        ) : (
                                            <div className="space-y-2">
                                                <button onClick={confirmStopRecording}
                                                    className="w-full py-4 rounded-xl font-bold text-base shadow-xl bg-red-500 text-white hover:bg-red-600 transition flex items-center justify-center gap-2 animate-pulse">
                                                    <Icon name="square" fill="currentColor" /> {t.stopExport}
                                                </button>
                                                <p className="text-[10px] text-red-500 dark:text-red-400 text-center font-bold animate-pulse">{t.recWarning}</p>
                                            </div>
                                        )}
                                    </div>
                                )}
                                
                                {/* CRITICAL: INFINITE SPACER FOR MOBILE 
                                    This invisible div ensures the last buttons can be scrolled 
                                    up to the middle of the screen, preventing thumb fatigue.
                                */}
                                <div className="h-40 md:h-0 w-full shrink-0" aria-hidden="true"></div>
                            </div>
                        </div>
                    </main>

                    <div className="fixed top-0 right-0 p-4 z-50 pointer-events-none">
                        {toasts.map(t => <div key={t.id} className="pointer-events-auto mb-2"><Toast {...t} onClose={() => removeToast(t.id)} /></div>)}
                    </div>
                    <ConfirmModal isOpen={showStopConfirm} title={t.recStopTitle} message={t.recStopMsg} onConfirm={executeStopRecording} onCancel={() => setShowStopConfirm(false)} texts={{stop: t.stop, cancel: t.cancel}} />
                    <FileInfoModal isOpen={showFileInfo} onClose={() => setShowFileInfo(false)} />
                    {/* New Guide Modal */}
                    <RecDurationModal isOpen={showDurationGuide} onClose={() => setShowDurationGuide(false)} texts={t} />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
