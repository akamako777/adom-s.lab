<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <!-- スマホでも無理に縮小せず、PC用の幅(1100px)として認識させる -->
    <meta name="viewport" content="width=1100">
    <title>先生のクラス管理ツール Pro</title>
    
    <!-- Tailwind CSS (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (cdnjs: より安定) -->
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (cdnjs) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    
    <!-- SheetJS (cdnjs) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- JSZip (ZIP圧縮処理) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;500;700&display=swap');
        
        body {
            font-family: 'Zen Maru Gothic', sans-serif;
            background-color: #f0f9ff;
            /* 画面が狭くても潰れないように最小幅を固定し、横スクロールを許可する */
            min-width: 1100px;
            overflow-x: auto;
        }

        /* 印刷設定（通常画面用） */
        @media print {
            body { 
                display: none; /* 通常の印刷機能は無効化し、JSで制御する */
            }
        }

        .roulette-active .seat-card {
            animation: pulse 0.1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.02); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        /* モーダル */
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.5);
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            z-index: 1000;
            display: grid;
            place-items: center;
            overflow-y: auto;
        }
        
        .animate-fade-in {
            animation: fadeIn 0.2s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        /* トースト通知 */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .toast {
            min-width: 250px;
            padding: 16px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            animation: slideIn 0.3s ease-out;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toast-success { background-color: #10B981; }
        .toast-error { background-color: #EF4444; }
        .toast-info { background-color: #3B82F6; }
        .toast-warning { background-color: #F59E0B; }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* 写真アップロード用のドロップゾーン */
        .drop-zone {
            border: 2px dashed #93c5fd;
            transition: all 0.2s;
        }
        .drop-zone.dragover {
            background-color: #eff6ff;
            border-color: #3b82f6;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- ユーティリティ: アイコン ---
        const Icons = {
            Users: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>,
            Grid: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>,
            Calendar: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>,
            Layers: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>,
            Image: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>,
            Download: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>,
            UploadCloud: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 16 12 12 8 16"/><line x1="12" y1="12" x2="12" y2="21"/><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"/><polyline points="16 16 12 12 8 16"/></svg>,
            Printer: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/></svg>,
            Trash: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>,
            Shuffle: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 3 21 3 21 8"/><line x1="4" y1="20" x2="21" y2="3"/><polyline points="21 16 21 21 16 21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="4" y1="4" x2="9" y2="9"/></svg>,
            Plus: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
            Alert: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>,
            Check: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"/></svg>,
            Smile: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M8 14s1.5 2 4 2 4-2 4-2"/><line x1="9" y1="9" x2="9.01" y2="9"/><line x1="15" y1="9" x2="15.01" y2="9"/></svg>,
            ClipboardList: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><path d="M12 11h4"/><path d="M12 16h4"/><path d="M8 11h.01"/><path d="M8 16h.01"/></svg>,
            X: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>,
            ArrowDown: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><polyline points="19 12 12 19 5 12"/></svg>,
            ArrowUp: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg>,
            RefreshCw: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>,
            Lock: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>,
            Unlock: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>,
            AlertOctagon: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>,
            Info: ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>,
            Camera: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>,
            RotateCw: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg>,
            Save: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>,
            FileUp: ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><polyline points="16 13 12 9 8 13"/><line x1="12" y1="9" x2="12" y2="17"/></svg>
        };

        // --- 印刷用ユーティリティ (第3引数でオプションを拡張) ---
        const handlePrint = (targetId, showToast, options = {}) => {
            const content = document.getElementById(targetId);
            const header = document.getElementById('print-header');
            
            // 既存コードとの互換性対応 (第3引数が boolean だった場合)
            let isPhotoPrint = false;
            let orientation = 'portrait';
            if (typeof options === 'boolean') {
                isPhotoPrint = options;
            } else if (typeof options === 'object' && options !== null) {
                isPhotoPrint = options.isPhotoPrint || false;
                orientation = options.orientation || 'portrait';
            }

            if (!content) {
                showToast("印刷対象が見つかりません", "error");
                return;
            }

            const contentHtml = content.innerHTML;
            const headerHtml = header ? header.innerHTML : '';
            const printWindow = window.open('', '_blank', 'height=800,width=1000');

            if (!printWindow) {
                showToast("ポップアップがブロックされました。設定を確認してください。", "error");
                return;
            }

            const customCSS = isPhotoPrint ? `
                .photo-grid { display: grid; gap: 10px; }
                .grid-cols-4 { grid-template-columns: repeat(4, 1fr); }
                .grid-cols-6 { grid-template-columns: repeat(6, 1fr); }
                .grid-cols-8 { grid-template-columns: repeat(8, 1fr); }
                .grid-cols-12 { grid-template-columns: repeat(12, 1fr); }
                .photo-card { border: 1px solid #ccc; padding: 5px; text-align: center; page-break-inside: avoid; }
                .photo-img { width: 100%; height: auto; object-fit: cover; aspect-ratio: 3/4; border: 1px solid #eee; margin-bottom: 5px; }
                .photo-empty { width: 100%; aspect-ratio: 3/4; border: 1px dashed #ccc; margin-bottom: 5px; background: #fafafa; }
                .photo-name { font-size: 12px; font-weight: bold; }
                .photo-no { font-size: 10px; color: #666; }
            ` : `
                table { border-collapse: collapse; width: 100%; }
                th, td { border: 1px solid #000; padding: 4px; }
            `;

            printWindow.document.write(`
                <html>
                <head>
                    <meta charset="UTF-8">
                    <title>印刷プレビュー</title>
                    <script src="https://cdn.tailwindcss.com"><\/script>
                    <style>
                        @import url('https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;500;700&display=swap');
                        body { 
                            font-family: 'Zen Maru Gothic', sans-serif;
                            background-color: white; 
                            -webkit-print-color-adjust: exact; 
                            print-color-adjust: exact;
                            padding: 20px;
                        }
                        .print-header-wrapper { text-align: center; margin-bottom: 2rem; }
                        .no-print { display: none !important; }
                        @page { size: ${orientation}; margin: 10mm; }
                        ${customCSS}
                    </style>
                </head>
                <body>
                    <div class="print-header-wrapper">${headerHtml}</div>
                    <div>${contentHtml}</div>
                    <script>
                        window.onload = function() {
                            setTimeout(function() { window.print(); }, 500);
                        };
                    <\/script>
                </body>
                </html>
            `);
            printWindow.document.close();
        };

        // --- 画像処理ユーティリティ (メモリ節約) ---
        const resizeImage = (file, maxDimension = 1200) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        let { width, height } = img;
                        if (width > maxDimension || height > maxDimension) {
                            if (width > height) {
                                height = Math.round((height * maxDimension) / width);
                                width = maxDimension;
                            } else {
                                width = Math.round((width * maxDimension) / height);
                                height = maxDimension;
                            }
                        }
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg', 0.8));
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        };

        const rotateImage = (dataUrl) => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.height;
                    canvas.height = img.width;
                    const ctx = canvas.getContext('2d');
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(Math.PI / 2);
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    resolve(canvas.toDataURL('image/jpeg', 0.8));
                };
                img.onerror = reject;
                img.src = dataUrl;
            });
        };

        const dataURLtoBlob = (dataurl) => {
            let arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1];
            let bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
            while(n--){ u8arr[n] = bstr.charCodeAt(n); }
            return new Blob([u8arr], {type:mime});
        };

        // --- コンポーネント: トースト通知 ---
        const ToastContainer = ({ toasts }) => {
            return (
                <div className="toast-container no-print">
                    {toasts.map(t => (
                        <div key={t.id} className={`toast toast-${t.type}`}>
                            {t.type === 'success' && <Icons.Check size={20} />}
                            {t.type === 'error' && <Icons.Alert size={20} />}
                            {t.type === 'info' && <Icons.Info size={20} />}
                            {t.type === 'warning' && <Icons.Alert size={20} />}
                            {t.message}
                        </div>
                    ))}
                </div>
            );
        };

        // --- コンポーネント: UIパーツ ---
        const Button = ({ onClick, children, variant = "primary", className = "", disabled = false, title = "" }) => {
            const baseStyle = "px-4 py-2 rounded-lg font-bold transition flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed shadow-sm text-sm whitespace-nowrap";
            const variants = {
                primary: "bg-blue-500 hover:bg-blue-600 text-white",
                secondary: "bg-white hover:bg-gray-50 text-gray-700 border border-gray-300",
                danger: "bg-red-500 hover:bg-red-600 text-white",
                success: "bg-green-500 hover:bg-green-600 text-white",
                ghost: "bg-transparent hover:bg-gray-100 text-gray-600"
            };
            return (
                <button onClick={onClick} className={`${baseStyle} ${variants[variant]} ${className}`} disabled={disabled} title={title}>
                    {children}
                </button>
            );
        };

        const Card = ({ children, title, action, id, subtitle, className="" }) => (
            <div id={id} className={`bg-white rounded-xl shadow-lg p-6 mb-6 ${className}`}>
                {(title || action || subtitle) && (
                    <div className="mb-4 border-b pb-2 no-print">
                        <div className="flex justify-between items-center">
                            {title && <h2 className="text-xl font-bold text-gray-800 flex items-center gap-2">{title}</h2>}
                            <div>{action}</div>
                        </div>
                        {subtitle && <p className="text-xs text-gray-500 mt-1">{subtitle}</p>}
                    </div>
                )}
                {children}
            </div>
        );

        const ConfirmModal = ({ isOpen, onClose, onConfirm, message }) => {
            if (!isOpen) return null;
            return (
                <div className="modal-overlay no-print">
                    <div className="bg-white rounded-xl p-6 shadow-2xl max-w-sm w-full animate-fade-in">
                        <h3 className="text-lg font-bold mb-2 flex items-center gap-2 text-gray-800">
                            <Icons.Alert /> 確認
                        </h3>
                        <p className="text-gray-600 mb-6 whitespace-pre-wrap">{message}</p>
                        <div className="flex justify-end gap-3">
                            <Button variant="secondary" onClick={onClose}>キャンセル</Button>
                            <Button variant="danger" onClick={() => { onConfirm(); onClose(); }}>実行する</Button>
                        </div>
                    </div>
                </div>
            );
        };

        const PasswordModal = ({ isOpen, onClose, onConfirm, isLocking }) => {
            const [pass, setPass] = useState('');
            if(!isOpen) return null;
            return (
                <div className="modal-overlay no-print">
                    <div className="bg-white rounded-xl p-6 shadow-2xl max-w-sm w-full animate-fade-in">
                        <h3 className="text-lg font-bold mb-2 flex items-center gap-2 text-gray-800">
                            {isLocking ? <Icons.Lock /> : <Icons.Unlock />} 
                            {isLocking ? "ロック設定" : "ロック解除"}
                        </h3>
                        <p className="text-sm text-gray-600 mb-2">
                            {isLocking ? "パスワードを設定してください" : "パスワードを入力してください"}
                        </p>
                        <input type="password" className="w-full border rounded p-2 mb-4 font-mono text-center text-lg" 
                            autoFocus
                            placeholder="****"
                            value={pass} onChange={e=>setPass(e.target.value)} />
                        <div className="flex justify-end gap-3">
                            <Button variant="secondary" onClick={()=>{setPass(''); onClose();}}>キャンセル</Button>
                            <Button variant="primary" onClick={()=>{ onConfirm(pass); setPass(''); }} disabled={!pass}>OK</Button>
                        </div>
                    </div>
                </div>
            );
        };

        const PasteModal = ({ isOpen, onClose, onImport, title, placeholder }) => {
            const [text, setText] = useState('');
            if (!isOpen) return null;
            return (
                <div className="modal-overlay no-print">
                    <div className="bg-white rounded-xl shadow-2xl w-[90vw] max-w-lg flex flex-col max-h-[80vh] animate-fade-in">
                        <div className="p-4 border-b flex justify-between items-center bg-gray-50 rounded-t-xl">
                            <h3 className="font-bold text-lg text-gray-800 flex items-center gap-2">
                                <Icons.ClipboardList /> {title}
                            </h3>
                            <button onClick={onClose} className="text-gray-500 hover:text-gray-700"><Icons.X /></button>
                        </div>
                        <div className="p-6 flex-grow overflow-auto">
                            <p className="text-sm text-gray-600 mb-2">Excelなどのセルをコピーして、下の枠に貼り付けてください。</p>
                            <textarea 
                                className="w-full h-64 p-4 border rounded-lg font-mono text-sm bg-gray-50"
                                placeholder={placeholder} value={text} onChange={(e) => setText(e.target.value)}
                            ></textarea>
                        </div>
                        <div className="p-4 border-t flex justify-end gap-2 bg-gray-50 rounded-b-xl">
                            <Button variant="secondary" onClick={onClose}>キャンセル</Button>
                            <Button variant="primary" onClick={() => { onImport(text); setText(''); onClose(); }} disabled={!text.trim()}>
                                <Icons.Check /> 取り込み
                            </Button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- 1. 名簿登録 ---
        const StudentRegistration = ({ data, setData, isLocked, setIsLocked, lockPass, setLockPass, resetAll, showToast }) => {
            const [isImportModalOpen, setImportModalOpen] = useState(false);
            const [deleteId, setDeleteId] = useState(null);
            const [showPassModal, setShowPassModal] = useState(false);
            const [showResetConfirm, setShowResetConfirm] = useState(false);
            const fileInputRef = useRef(null);

            const generateId = () => 's_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);

            // 男女・混合カウント
            const counts = data.students.reduce((acc, s) => {
                if(s.gender === 'boy') acc.boy++;
                else if(s.gender === 'girl') acc.girl++;
                else acc.mixed++;
                return acc;
            }, {boy:0, girl:0, mixed:0});

            const addStudent = () => {
                const newStudent = {
                    id: generateId(),
                    name: '',
                    gender: 'mixed',
                    needsSupport: false,
                    fixedSeat: null,
                    avoid: ['', '', '']
                };
                setData(prev => ({ ...prev, students: [...prev.students, newStudent] }));
            };

            const update = (id, field, val) => {
                if (field === 'fixedSeat') {
                    if (val === '') {
                        setData(prev => ({ ...prev, students: prev.students.map(s => s.id === id ? { ...s, [field]: null } : s) }));
                        return;
                    }

                    let seatNum = parseInt(val);
                    if (isNaN(seatNum)) return;
                    if (seatNum < 1) seatNum = 1;
                    if (seatNum > data.students.length) seatNum = data.students.length;

                    // 重複チェック
                    const isDuplicate = data.students.some(s => s.id !== id && s.fixedSeat === seatNum);
                    if (isDuplicate) {
                        showToast(`席番号 ${seatNum} は既に他の生徒に設定されています`, "error");
                        return;
                    }
                    val = seatNum;
                }
                
                setData(prev => ({ ...prev, students: prev.students.map(s => s.id === id ? { ...s, [field]: val } : s) }));
            };

            const remove = () => {
                setData(prev => ({ ...prev, students: prev.students.filter(s => s.id !== deleteId) }));
                setDeleteId(null);
                showToast("生徒を削除しました", "success");
            };
            const bulkImport = (text) => {
                const lines = text.split(/\r\n|\n|\r/).filter(l => l.trim());
                const newStudents = lines.map((l, i) => {
                    const parts = l.split('\t');
                    let gender = 'mixed';
                    if (parts[1] && /男|boy/i.test(parts[1])) gender = 'boy';
                    if (parts[1] && /女|girl/i.test(parts[1])) gender = 'girl';
                    return { 
                        id: generateId() + '_' + i, 
                        name: parts[0].trim(), gender, needsSupport: false, fixedSeat: null, avoid: ['', '', ''] 
                    };
                });
                setData(prev => ({ ...prev, students: [...prev.students, ...newStudents] }));
                showToast(`${newStudents.length}名のデータを取り込みました`, "success");
            };

            const handleLockAction = (inputPass) => {
                const input = String(inputPass);
                const saved = String(lockPass);

                if(isLocked) {
                    if(input === saved) {
                        setIsLocked(false);
                        setLockPass(null); 
                        showToast("ロックを解除しました", "success");
                    } else {
                        showToast("パスワードが違います", "error");
                    }
                } else {
                    setLockPass(input);
                    setIsLocked(true);
                    showToast("編集ロックを設定しました", "success");
                }
                setShowPassModal(false);
            };

            // --- JSONバックアップ・復元機能 ---
            const exportData = () => {
                const dataStr = JSON.stringify(data, null, 2);
                const blob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `クラス管理データ_${data.settings.gradeClass || '未設定'}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToast("バックアップデータを保存しました", "success");
            };

            const importData = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const parsed = JSON.parse(event.target.result);
                        if(parsed.students && parsed.settings) {
                            setData(parsed);
                            showToast("データを復元しました", "success");
                        } else {
                            showToast("無効なファイル形式です", "error");
                        }
                    } catch (err) {
                        showToast("ファイルの読み込みに失敗しました", "error");
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; // Reset
            };

            return (
                <div className="space-y-6">
                    <ConfirmModal isOpen={!!deleteId} onClose={() => setDeleteId(null)} onConfirm={remove} message="本当に削除しますか？" />
                    <ConfirmModal isOpen={showResetConfirm} onClose={() => setShowResetConfirm(false)} onConfirm={() => {resetAll(); setShowResetConfirm(false);}} message="注意：すべてのデータ（名簿、設定、班など）が消去されます。\n本当によろしいですか？" />
                    <PasteModal isOpen={isImportModalOpen} onClose={() => setImportModalOpen(false)} onImport={bulkImport} 
                        title="Excelから一括登録" placeholder={`氏名\n氏名\t性別\n...`} />
                    <PasswordModal isOpen={showPassModal} onClose={()=>setShowPassModal(false)} onConfirm={handleLockAction} isLocking={!isLocked} />
                    
                    <Card title="クラス基本情報" action={
                        <div className="flex gap-2">
                            <input type="file" accept=".json" ref={fileInputRef} className="hidden" onChange={importData} />
                            <Button variant="ghost" className="text-sm border border-gray-200" onClick={() => fileInputRef.current.click()} title="JSONファイルから設定を復元"><Icons.FileUp /> 復元</Button>
                            <Button variant="ghost" className="text-sm border border-gray-200" onClick={exportData} title="現在の設定と名簿をバックアップ保存"><Icons.Save /> バックアップ</Button>
                        </div>
                    } subtitle="※バックアップデータ(JSON)にはセキュリティ保護のため写真画像は含まれません。">
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <label className="block"><span className="text-gray-700 font-bold">学校名</span><input type="text" disabled={isLocked} className="mt-1 block w-full border rounded p-2" value={data.settings.school} onChange={e => setData({...data, settings: {...data.settings, school: e.target.value}})} /></label>
                            <label className="block"><span className="text-gray-700 font-bold">学年・組</span><input type="text" disabled={isLocked} className="mt-1 block w-full border rounded p-2" value={data.settings.gradeClass} onChange={e => setData({...data, settings: {...data.settings, gradeClass: e.target.value}})} /></label>
                            <label className="block"><span className="text-gray-700 font-bold">担任名</span><input type="text" disabled={isLocked} className="mt-1 block w-full border rounded p-2" value={data.settings.teacher} onChange={e => setData({...data, settings: {...data.settings, teacher: e.target.value}})} /></label>
                        </div>
                    </Card>

                    <Card title={`生徒名簿 (${data.students.length}名)`} action={
                        <div className="flex gap-2">
                            <Button onClick={() => setShowResetConfirm(true)} variant="danger" title="全データ初期化">
                                <Icons.AlertOctagon /> オールクリア
                            </Button>

                            <Button onClick={() => setShowPassModal(true)} variant={isLocked ? "danger" : "secondary"} title={isLocked ? "ロック解除" : "編集ロック"}>
                                {isLocked ? <Icons.Lock /> : <Icons.Unlock />} {isLocked ? "解除" : "ロック"}
                            </Button>
                            
                            <Button onClick={() => setImportModalOpen(true)} disabled={isLocked} variant="secondary"><Icons.ClipboardList /> Excel取込</Button>
                            <Button onClick={addStudent} disabled={isLocked} variant="success"><Icons.Plus /> 追加</Button>
                        </div>
                    }>
                        <div className="mb-4 flex gap-4 text-sm font-bold text-gray-600 bg-gray-50 p-2 rounded no-print">
                            <span className="text-blue-600">男: {counts.boy}名</span>
                            <span className="text-red-600">女: {counts.girl}名</span>
                            <span className="text-gray-600">未設定: {counts.mixed}名</span>
                        </div>

                        {isLocked ? (
                            <div className="text-center py-10 text-gray-400 bg-gray-50 rounded border-2 border-dashed">
                                <Icons.Lock size={48} />
                                <p className="mt-2">名簿はロックされています</p>
                            </div>
                        ) : (
                            <div className="overflow-x-auto">
                                <table className="min-w-full divide-y divide-gray-200">
                                    <thead className="bg-gray-50">
                                        <tr>
                                            <th className="px-3 py-3 text-left text-xs font-bold text-gray-500 uppercase">No.</th>
                                            <th className="px-3 py-3 text-left text-xs font-bold text-gray-500 uppercase w-40">氏名</th>
                                            <th className="px-3 py-3 text-left text-xs font-bold text-gray-500 uppercase">性別</th>
                                            <th className="px-3 py-3 text-left text-xs font-bold text-gray-500 uppercase">指導対象/固定席</th>
                                            <th className="px-3 py-3 text-left text-xs font-bold text-gray-500 uppercase">NG生徒</th>
                                            <th className="px-3 py-3 text-center text-xs font-bold text-gray-500 uppercase">削除</th>
                                        </tr>
                                    </thead>
                                    <tbody className="bg-white divide-y divide-gray-200">
                                        {data.students.map((s, i) => (
                                            <tr key={s.id}>
                                                <td className="px-3 py-2 text-gray-500">{i + 1}</td>
                                                <td className="px-3 py-2"><input className="w-full border rounded p-1" value={s.name} onChange={e => update(s.id, 'name', e.target.value)} /></td>
                                                <td className="px-3 py-2">
                                                    <select className="border rounded p-1" value={s.gender} onChange={e => update(s.id, 'gender', e.target.value)}>
                                                        <option value="mixed">任意</option><option value="boy">男</option><option value="girl">女</option>
                                                    </select>
                                                </td>
                                                <td className="px-3 py-2">
                                                    <div className="flex items-center gap-2">
                                                        <input type="checkbox" checked={s.needsSupport} onChange={e => update(s.id, 'needsSupport', e.target.checked)} />
                                                        {s.needsSupport && <input type="number" min="1" max={data.students.length} className="w-12 border rounded p-1 text-xs" placeholder="席" value={s.fixedSeat||''} onChange={e => update(s.id, 'fixedSeat', e.target.value)} />}
                                                    </div>
                                                </td>
                                                <td className="px-3 py-2">
                                                    <div className="flex gap-1">{[0,1,2].map(k => (
                                                        <select key={k} className="w-20 text-xs border rounded" value={s.avoid[k]} onChange={e => {
                                                            const nav = [...s.avoid]; nav[k] = e.target.value; update(s.id, 'avoid', nav);
                                                        }}>
                                                            <option value="">-</option>
                                                            {data.students.filter(o => o.id !== s.id).map(o => <option key={o.id} value={o.id}>{o.name}</option>)}
                                                        </select>
                                                    ))}</div>
                                                </td>
                                                <td className="px-3 py-2 text-center"><button onClick={() => setDeleteId(s.id)} className="text-red-500"><Icons.Trash /></button></td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}
                    </Card>
                </div>
            );
        };

        // --- 2. 席替え (強化版) ---
        const SeatingTool = ({ data, setData, showToast }) => {
            const [layout, setLayout] = useState([]);
            const [running, setRunning] = useState(false);
            
            useEffect(() => {
                const cols = data.seatConfig.cols || 1;
                const rows = data.seatConfig.rows || 1;
                const total = cols * rows;
                const students = data.students || [];
                
                const newLayout = Array(total).fill(null);
                students.forEach((s, i) => { if (i < total) newLayout[i] = s; });
                setLayout(newLayout);
            }, [data.seatConfig.rows, data.seatConfig.cols, data.students.length]); 

            const safeCols = Math.max(1, data.seatConfig.cols || 1);
            const safeRows = Math.max(1, data.seatConfig.rows || 1);
            const seatCount = safeRows * safeCols;
            const studentCount = data.students.length;
            const isShortage = seatCount < studentCount;

            const shuffle = () => {
                setRunning(true);
                let count = 0;
                const timer = setInterval(() => {
                    setLayout(prev => {
                        const temp = [...prev];
                        for (let i = temp.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [temp[i], temp[j]] = [temp[j], temp[i]];
                        }
                        return temp;
                    });
                    if (++count > 15) {
                        clearInterval(timer);
                        finalize();
                    }
                }, 100);
            };

            const finalize = () => {
                const total = safeRows * safeCols;
                if (total <= 0) {
                    setRunning(false);
                    return;
                }

                let best = null, minScore = Infinity;
                const TRIALS = 500; 
                
                for(let k=0; k < TRIALS; k++) {
                    const current = Array(total).fill(null);
                    const pool = [...data.students];
                    
                    const fixed = pool.filter(s => s.fixedSeat !== null);
                    const others = pool.filter(s => s.fixedSeat === null);
                    
                    fixed.forEach(s => {
                        const seatIdx = s.fixedSeat - 1;
                        if(seatIdx >= 0 && seatIdx < total && !current[seatIdx]) {
                            current[seatIdx] = s;
                        } else {
                            others.push(s);
                        }
                    });

                    // othersをシャッフル
                    for (let i = others.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [others[i], others[j]] = [others[j], others[i]];
                    }
                    
                    // 空いている席に詰める
                    let p = 0;
                    for(let i=0; i<total; i++) if(!current[i] && p < others.length) current[i] = others[p++];
                    
                    let score = 0;
                    for(let i=0; i<total; i++) {
                        const s1 = current[i];
                        if(!s1) continue;

                        // --- 右隣チェック ---
                        if((i+1) % safeCols !== 0) {
                            const s2 = current[i+1];
                            if(s2) {
                                if(s1.avoid.includes(s2.id) || s2.avoid.includes(s1.id)) score += 100;
                                if (s1.gender !== 'mixed' && s2.gender !== 'mixed' && s1.gender === s2.gender) score += 10; 
                            }
                        }

                        // --- 真下（前後）チェック ---
                        if (i + safeCols < total) {
                            const sDown = current[i + safeCols];
                            if (sDown) {
                                if (s1.avoid.includes(sDown.id) || sDown.avoid.includes(s1.id)) score += 100;
                            }
                        }
                    }

                    if(score < minScore) { minScore = score; best = current; }
                    if(score === 0) break; 
                }
                
                setLayout(best);
                setRunning(false);
                if (minScore === 0) {
                    showToast("最適な配置が見つかりました！", "success");
                } else if (minScore < 100) {
                    showToast("配置完了（性別などの条件を一部妥協しました）", "info");
                } else {
                    showToast("配置完了（※NG条件を完全に満たせませんでした）", "error");
                }
            };

            const onDragStart = (e, i) => e.dataTransfer.setData("idx", i);
            const onDragOver = (e) => e.preventDefault();
            const onDrop = (e, to) => {
                const from = e.dataTransfer.getData("idx");
                if(from === "") return;
                const next = [...layout];
                [next[from], next[to]] = [next[to], next[from]];
                setLayout(next);
            };

            const doPrint = () => handlePrint('print-target', showToast);

            const doExcel = () => {
                if (layout.length === 0) return showToast("座席データがありません", "error");

                const wb = XLSX.utils.book_new();
                const rows = [];

                const pulpitRow = Array(safeCols).fill("");
                const centerIdx = Math.floor((safeCols - 1) / 2);
                pulpitRow[centerIdx] = "教卓";
                rows.push(pulpitRow);
                rows.push(Array(safeCols).fill(""));

                for (let r = 0; r < safeRows; r++) {
                    const rowData = [];
                    for (let c = 0; c < safeCols; c++) {
                        const idx = r * safeCols + c;
                        const student = layout[idx];
                        rowData.push(student ? student.name : "");
                    }
                    rows.push(rowData);
                }

                const ws = XLSX.utils.aoa_to_sheet(rows);
                XLSX.utils.book_append_sheet(wb, ws, "席替え結果");
                XLSX.writeFile(wb, "席替え表.xlsx");
                showToast("Excelファイルをダウンロードしました", "success");
            };
            
            const handleConfigChange = (field, value) => {
                let num = parseInt(value);
                if (isNaN(num)) num = 1;
                
                const currentVal = data.seatConfig[field];
                if (num > currentVal) {
                    const otherVal = field === 'cols' ? data.seatConfig.rows : data.seatConfig.cols;
                    const newTotal = num * otherVal;
                    const limit = Math.max(data.students.length * 2, 60);
                    if (newTotal > limit) return;
                }
                
                const safeVal = Math.max(1, num);
                setData({...data, seatConfig:{...data.seatConfig, [field]: safeVal}});
            };

            return (
                <div className="space-y-4">
                    <Card title="席替え" action={
                        <div className="flex gap-2">
                            <Button variant="secondary" onClick={doPrint}><Icons.Printer /> 印刷</Button>
                            <Button variant="secondary" onClick={doExcel}><Icons.Download /> Excel</Button>
                        </div>
                    }>
                        <div className="flex flex-wrap gap-4 mb-4 items-end no-print">
                            <label className="text-sm font-bold text-gray-700">横 <input type="number" className="w-16 border rounded p-1" value={data.seatConfig.cols} onChange={e=>handleConfigChange('cols', e.target.value)} /></label>
                            <label className="text-sm font-bold text-gray-700">縦 <input type="number" className="w-16 border rounded p-1" value={data.seatConfig.rows} onChange={e=>handleConfigChange('rows', e.target.value)} /></label>
                            <Button onClick={shuffle} disabled={running}><Icons.Shuffle /> スタート</Button>
                            
                            <div className={`ml-2 font-bold text-sm flex items-center px-3 py-1 rounded-full border ${isShortage ? 'bg-red-50 border-red-200' : 'bg-green-50 border-green-200'}`}>
                                <span className="mr-3 text-gray-600">生徒数: {studentCount}名</span>
                                {isShortage ? (
                                    <span className="text-red-500 flex items-center gap-1 animate-pulse">
                                        <Icons.Alert size={16}/> 席数が足りていません
                                    </span>
                                ) : (
                                    <span className="text-green-600 flex items-center gap-1">
                                        <Icons.Check size={16}/> OK
                                    </span>
                                )}
                            </div>
                        </div>
                        
                        <div id="print-target" className="p-4 border rounded bg-gray-50 print:border-none print:p-0">
                            <div className="text-center font-bold text-xl mb-4 text-gray-700 print:text-black">教卓</div>
                            <div className="grid gap-2 mx-auto" style={{ gridTemplateColumns: `repeat(${safeCols}, 1fr)` }}>
                                {layout.map((s, i) => (
                                    <div key={i} draggable={!running} onDragStart={e=>onDragStart(e, i)} onDragOver={onDragOver} onDrop={e=>onDrop(e, i)}
                                        className={`aspect-[5/4] border-2 rounded flex items-center justify-center p-1 text-center font-bold text-lg bg-white
                                            ${s?.gender==='boy'?'border-blue-300':s?.gender==='girl'?'border-red-300':'border-gray-300'}
                                            ${running ? 'bg-yellow-100' : ''}`}
                                    >
                                        {s ? s.name : ''}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </Card>
                </div>
            );
        };

        // --- 3. 係り・当番 (Smart Gender Logic & Fixed Slots & EXEMPTION Implemented) ---
        const DutyTool = ({ data, setData, showToast }) => {
            const initialDuties = data.dutyConfig.jobs?.length 
                ? data.dutyConfig.jobs.map(j => ({...j, genderReq: j.genderReq || 'none', fixedStudentId: j.fixedStudentId || null})) 
                : [{name:'黒板', count:2, genderReq:'none', fixedStudentId: null}];
            
            const [duties, setDuties] = useState(initialDuties);
            const [schedule, setSchedule] = useState([]);
            const [importOpen, setImportOpen] = useState(false);
            const [shiftVal, setShiftVal] = useState(1);
            
            useEffect(() => {
                setData(prev => ({...prev, dutyConfig: {...prev.dutyConfig, jobs: duties}}));
            }, [duties]);

            const usedStudentIds = new Set(
                duties
                    .filter(d => (d.genderReq === 'fixed' || d.genderReq === 'exempt') && d.fixedStudentId)
                    .map(d => d.fixedStudentId)
            );

            const availableStudents = data.students.filter(s => !usedStudentIds.has(s.id));
            
            const rosterCounts = availableStudents.reduce((acc, s) => {
                acc[s.gender || 'mixed'] = (acc[s.gender || 'mixed'] || 0) + 1;
                return acc;
            }, {boy:0, girl:0, mixed:0});

            const dutyCounts = duties.reduce((acc, d) => {
                if(d.genderReq === 'fixed' || d.genderReq === 'exempt') return acc; 
                if(d.genderReq === 'boy') acc.boy += d.count;
                else if(d.genderReq === 'girl') acc.girl += d.count;
                else acc.none += d.count;
                return acc;
            }, {boy:0, girl:0, none:0});

            const remainingStudents = availableStudents.length;
            const requiredSlots = dutyCounts.boy + dutyCounts.girl + dutyCounts.none;
            const remainingSlots = remainingStudents - requiredSlots;

            const updateCount = (index, newCount) => {
                if (isNaN(newCount) || newCount < 1) return; 
                if (newCount > duties[index].count && remainingSlots <= 0) {
                    showToast("生徒数が不足しています", "error");
                    return; 
                }
                const nd = [...duties];
                nd[index].count = newCount;
                setDuties(nd);
            };

            const updateGender = (index, val) => {
                const nd = [...duties];
                nd[index].genderReq = val;
                if(val === 'fixed' || val === 'exempt') nd[index].count = 1;
                setDuties(nd);
            };

            const updateFixedStudent = (index, sId) => {
                const nd = [...duties];
                nd[index].fixedStudentId = sId;
                setDuties(nd);
            };

            const addJob = () => {
                if (remainingSlots <= 0) return;
                setDuties([...duties, {name:'', count:1, genderReq:'none', fixedStudentId: null}]);
            };

            const generate = (sortType) => {
                if(data.students.length === 0) return showToast("生徒がいません", "error");

                if (rosterCounts.boy < dutyCounts.boy) return showToast(`男子が不足しています (必要: ${dutyCounts.boy}, 対象: ${rosterCounts.boy})`, "error");
                if (rosterCounts.girl < dutyCounts.girl) return showToast(`女子が不足しています (必要: ${dutyCounts.girl}, 対象: ${rosterCounts.girl})`, "error");
                if (remainingStudents < requiredSlots) return showToast("全体の生徒数が不足しています", "error");

                let pool = data.students.filter(s => !usedStudentIds.has(s.id));

                if(sortType === 'random') {
                    for (let i = pool.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [pool[i], pool[j]] = [pool[j], pool[i]];
                    }
                } else if (sortType === 'desc') {
                    pool.reverse();
                }

                const boysList = pool.filter(s => s.gender === 'boy');
                const girlsList = pool.filter(s => s.gender === 'girl');
                const allList = [...pool]; 

                const slotsInfo = [];
                let slotIndex = 0;
                duties.forEach(d => {
                    if (d.genderReq === 'fixed') {
                        slotsInfo.push({
                            id: `slot_${slotIndex++}`,
                            name: d.name,
                            genderReq: 'fixed',
                            fixedStudentId: d.fixedStudentId
                        });
                    } else if (d.genderReq === 'exempt') {
                        return;
                    } else {
                        for(let i=0; i<d.count; i++) {
                            slotsInfo.push({
                                id: `slot_${slotIndex++}`,
                                name: d.count > 1 ? `${d.name}${i+1}` : d.name,
                                genderReq: d.genderReq
                            });
                        }
                    }
                });

                const weeks = data.dutyConfig.duration || 10;
                const newSchedule = []; 
                
                let boyIndex = 0;
                let girlIndex = 0;
                let globalIndex = 0;

                for(let w=1; w<=weeks; w++) {
                    const weekAssignments = {};
                    const usedInThisWeek = new Set(); 

                    slotsInfo.forEach(slot => {
                        if (slot.genderReq === 'fixed') {
                            const student = data.students.find(s => s.id === slot.fixedStudentId);
                            weekAssignments[slot.id] = student ? student.name : "(未設定)";
                            if (student) usedInThisWeek.add(student.id);
                        }
                    });

                    slotsInfo.forEach(slot => {
                        if (slot.genderReq !== 'boy') return;
                        
                        if (boysList.length > 0) {
                            const student = boysList[boyIndex % boysList.length];
                            weekAssignments[slot.id] = student.name;
                            usedInThisWeek.add(student.id);
                            boyIndex++; 
                        } else {
                            weekAssignments[slot.id] = "(不足)";
                        }
                    });

                    slotsInfo.forEach(slot => {
                        if (slot.genderReq !== 'girl') return;

                        if (girlsList.length > 0) {
                            const student = girlsList[girlIndex % girlsList.length];
                            weekAssignments[slot.id] = student.name;
                            usedInThisWeek.add(student.id);
                            girlIndex++; 
                        } else {
                            weekAssignments[slot.id] = "(不足)";
                        }
                    });

                    slotsInfo.forEach(slot => {
                        if (slot.genderReq !== 'none') return;

                        let found = false;
                        for (let k = 0; k < allList.length; k++) {
                            const currentIndex = (globalIndex + k) % allList.length;
                            const student = allList[currentIndex];
                            
                            if (!usedInThisWeek.has(student.id)) {
                                weekAssignments[slot.id] = student.name;
                                usedInThisWeek.add(student.id);
                                globalIndex = (currentIndex + 1) % allList.length; 
                                found = true;
                                break;
                            }
                        }
                        if (!found) weekAssignments[slot.id] = "-";
                    });

                    if (requiredSlots === remainingStudents) {
                         boyIndex += shiftVal;
                         girlIndex += shiftVal;
                         globalIndex += shiftVal;
                    }

                    newSchedule.push({ id: w, mapping: weekAssignments });
                }

                setSchedule({ slots: slotsInfo, weeks: newSchedule });
                showToast("当番表を作成しました", "success");
            };

            const doPrint = () => handlePrint('print-target', showToast);
            const doExcel = () => {
                if(!schedule.slots) return;
                const rows = [];
                const header = ["係名", ...schedule.weeks.map(w => `${w.id}${data.dutyConfig.type==='week'?'週':'月'}`)];
                rows.push(header);
                schedule.slots.forEach(slot => {
                    const row = [slot.name];
                    schedule.weeks.forEach(w => {
                        row.push(w.mapping[slot.id] || "");
                    });
                    rows.push(row);
                });
                const ws = XLSX.utils.aoa_to_sheet(rows);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "当番表");
                XLSX.writeFile(wb, "当番表.xlsx");
                showToast("Excelファイルをダウンロードしました", "success");
            };

            return (
                <div className="space-y-6">
                    <PasteModal isOpen={importOpen} onClose={()=>setImportOpen(false)} title="係リスト取込" placeholder={`係名\n係名\t人数`}
                        onImport={(txt)=>{
                            const ls = txt.split(/\r\n|\n/).filter(l=>l.trim());
                            const nd = ls.map(l=>{
                                const p = l.split('\t');
                                return {name:p[0].trim(), count:parseInt(p[1])||1, genderReq: 'none', fixedStudentId: null};
                            });
                            setDuties([...duties, ...nd]);
                        }}
                    />

                    <Card title="係り・当番設定">
                        <div className="space-y-4">
                            <div className="no-print">
                                <div className="flex justify-between mb-2">
                                    <h3 className="font-bold text-gray-700 flex items-center gap-2">
                                        係りの構成 
                                        <span className={`text-sm ml-2 ${remainingSlots < 0 ? 'text-red-500' : 'text-blue-600'}`}>
                                            (残り生徒: {remainingSlots}名)
                                        </span>
                                    </h3>
                                    <Button variant="secondary" onClick={()=>setImportOpen(true)} className="text-xs py-1"><Icons.ClipboardList /> 取込</Button>
                                </div>
                                <div className="bg-orange-50 p-2 mb-2 rounded text-xs text-orange-800 border border-orange-200">
                                    <span className="font-bold">現在の対象人数 (固定・免除除く):</span> 男子 {rosterCounts.boy}名 / 女子 {rosterCounts.girl}名 
                                </div>

                                {duties.map((d,i)=>(
                                    <div key={i} className={`flex gap-2 mb-2 items-center p-2 rounded ${d.genderReq==='exempt' ? 'bg-gray-100 border border-gray-300' : ''}`}>
                                        <input className="border rounded p-2 flex-grow" value={d.name} placeholder={d.genderReq === 'exempt' ? '理由 (例: 入院中)' : '係名'} onChange={e=>{
                                            const nd=[...duties]; nd[i].name=e.target.value; setDuties(nd);
                                        }} />
                                        
                                        <select className={`border rounded p-2 w-24 text-sm font-bold
                                            ${d.genderReq==='boy'?'bg-blue-50 text-blue-800':
                                              d.genderReq==='girl'?'bg-red-50 text-red-800':
                                              d.genderReq==='fixed'?'bg-purple-100 text-purple-800':
                                              d.genderReq==='exempt'?'bg-gray-200 text-gray-600':''}`}
                                            value={d.genderReq} onChange={e=>updateGender(i, e.target.value)}
                                        >
                                            <option value="none">指定なし</option>
                                            <option value="boy">男子のみ</option>
                                            <option value="girl">女子のみ</option>
                                            <option value="fixed">★固定</option>
                                            <option value="exempt">🚫免除</option>
                                        </select>
                                        
                                        {d.genderReq === 'fixed' || d.genderReq === 'exempt' ? (
                                            <select className={`border rounded p-2 w-40 text-sm ${d.genderReq==='fixed'?'bg-purple-50':'bg-gray-50'}`} 
                                                value={d.fixedStudentId || ''} 
                                                onChange={e=>updateFixedStudent(i, e.target.value)}
                                            >
                                                <option value="">生徒を選択...</option>
                                                {data.students.map(s => {
                                                    if (s.id === d.fixedStudentId || !usedStudentIds.has(s.id)) {
                                                        return <option key={s.id} value={s.id}>{s.name}</option>;
                                                    }
                                                    return null;
                                                })}
                                            </select>
                                        ) : (
                                            <input type="number" className="border rounded p-2 w-16" value={d.count} min="1" onChange={e => updateCount(i, parseInt(e.target.value))} />
                                        )}
                                        
                                        <Button variant="danger" onClick={()=>setDuties(duties.filter((_,x)=>x!==i))}><Icons.Trash /></Button>
                                    </div>
                                ))}
                                <Button variant="secondary" onClick={addJob} disabled={remainingSlots <= 0} title={remainingSlots <= 0 ? "生徒数上限に達しています" : ""}>
                                    <Icons.Plus /> 追加
                                </Button>
                            </div>

                            <div className="bg-gray-50 p-4 rounded-lg border no-print">
                                <div className="flex flex-wrap gap-4 items-center mb-4">
                                    <label className="font-bold text-sm">期間: 
                                        <select className="ml-2 border rounded p-1" value={data.dutyConfig.type} onChange={e=>setData({...data, dutyConfig:{...data.dutyConfig, type:e.target.value}})}>
                                            <option value="week">週交代</option><option value="month">月交代</option>
                                        </select>
                                    </label>
                                    <label className="font-bold text-sm">回数: 
                                        <input type="number" className="ml-2 w-16 border rounded p-1" value={data.dutyConfig.duration} onChange={e=>setData({...data, dutyConfig:{...data.dutyConfig, duration:parseInt(e.target.value)}})} />
                                    </label>
                                    <label className="font-bold text-sm">ずらす数: 
                                        <input type="number" className="ml-2 w-12 border rounded p-1" value={shiftVal} min="1" onChange={e=>setShiftVal(parseInt(e.target.value)||1)} />
                                    </label>
                                </div>
                                
                                <div className="flex flex-col gap-2">
                                    <div className="text-sm font-bold text-gray-600">① 名簿の並び順を選んで作成</div>
                                    <div className="flex gap-2 flex-wrap">
                                        <Button onClick={()=>generate('asc')} variant="secondary" title="名簿順のまま上から順に割り当てます"><Icons.ArrowDown /> 名簿順（昇順）</Button>
                                        <Button onClick={()=>generate('desc')} variant="secondary" title="名簿の逆順で上から順に割り当てます"><Icons.ArrowUp /> 逆順（降順）</Button>
                                        <Button onClick={()=>generate('random')} variant="secondary" title="シャッフルしてから順に割り当てます"><Icons.Shuffle /> ランダム</Button>
                                    </div>
                                    <div className="text-xs text-gray-500 mt-2 p-2 bg-white border rounded">
                                        <p className="font-bold text-gray-700 mb-1">💡 ヒント</p>
                                        <ul className="list-disc list-inside space-y-1">
                                            <li><strong>「固定」</strong>: 特定の生徒をその係にロックします（他の係からは除外）。</li>
                                            <li><strong>「免除」</strong>: 生徒を今回の係決め全体から除外します（人数も減ります）。係名欄に理由をメモできます。</li>
                                            <li>固定・免除で選んだ生徒は、他のプルダウンから自動的に消えるので重複しません。</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>

                        {schedule.slots && (
                            <div className="mt-6">
                                <div className="flex justify-end gap-2 mb-2 no-print">
                                    <Button variant="secondary" onClick={doPrint}><Icons.Printer /> 印刷</Button>
                                    <Button variant="secondary" onClick={doExcel}><Icons.Download /> Excel</Button>
                                </div>
                                <div id="print-target" className="overflow-x-auto border rounded">
                                    <table className="w-full text-sm text-center border-collapse">
                                        <thead>
                                            <tr className="bg-gray-100">
                                                <th className="border p-2 min-w-[100px] bg-gray-200">係 \ 回</th>
                                                {schedule.weeks.map(w => (
                                                    <th key={w.id} className="border p-2 min-w-[60px]">
                                                        {w.id}{data.dutyConfig.type==='week'?'週':'月'}
                                                    </th>
                                                ))}
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {schedule.slots.map((slot, i) => (
                                                <tr key={i}>
                                                    <td className="border p-2 font-bold bg-gray-50 text-left px-4">{slot.name}</td>
                                                    {schedule.weeks.map(w => (
                                                        <td key={w.id} className="border p-2">
                                                            {w.mapping[slot.id]}
                                                        </td>
                                                    ))}
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        )}
                    </Card>
                </div>
            );
        };

        // --- 4. グループ分け ---
        const ClubTool = ({ data, setData, showToast }) => {
            const [groups, setGroups] = useState(data.clubConfig.clubs?.length ? data.clubConfig.clubs : [{id:'g1', name:'班1', members:[]}]);
            const [unassigned, setUnassigned] = useState([]);
            const [delGId, setDelGId] = useState(null);
            const [resetConfirm, setResetConfirm] = useState(false);

            useEffect(() => {
                const assigned = new Set();
                groups.forEach(g => g.members.forEach(m => assigned.add(m.id)));
                setUnassigned(data.students.filter(s => !assigned.has(s.id)));
            }, [data.students, groups]);

            useEffect(() => {
                setData(p=>({...p, clubConfig:{...p.clubConfig, clubs:groups}}));
            }, [groups]);

            const deleteGroup = () => {
                const g = groups.find(x => x.id === delGId);
                if(g) {
                    setGroups(groups.filter(x => x.id !== delGId));
                }
                setDelGId(null);
                showToast("班を削除しました", "success");
            };

            const resetAll = () => {
                setGroups([]);
                setResetConfirm(false);
                showToast("班をリセットしました", "success");
            };

            const canAddGroup = unassigned.length > 0;

            const addGroup = () => {
                if(!canAddGroup) return;
                const newId = 'g_' + Date.now().toString(36) + Math.random().toString(36).slice(2);
                setGroups([...groups, {id: newId, name:`班${groups.length+1}`, members:[]}]);
            };

            const onDrag = (e, sid, gid) => {
                e.dataTransfer.setData("sid", sid);
                e.dataTransfer.setData("src", gid);
            };
            const onDrop = (e, dest) => {
                const sid = e.dataTransfer.getData("sid");
                const src = e.dataTransfer.getData("src");
                if(!sid) return;
                
                if (dest !== 'un') {
                    const destGroup = groups.find(g => g.id === dest);
                    if (destGroup && destGroup.members.some(m => m.id === sid)) {
                        return; 
                    }
                }

                const student = data.students.find(s=>s.id===sid);
                let newGroups = groups.map(g => ({...g, members: [...g.members]}));
                
                if(src !== 'un') {
                    const srcG = newGroups.find(g => g.id === src);
                    if(srcG) srcG.members = srcG.members.filter(m => m.id !== sid);
                }
                
                if(dest !== 'un') {
                    const destG = newGroups.find(g => g.id === dest);
                    if(destG) destG.members.push(student);
                }
                
                setGroups(newGroups);
            };

            const autoAssign = (mode) => {
                if (groups.length === 0) return showToast("班を作ってください", "error");
                if (unassigned.length === 0) return showToast("未所属の生徒がいません", "error");

                let targets = [...unassigned];

                if (mode === 'random') {
                    const TRIALS = 500;
                    let bestGroups = null;
                    let minConflicts = Infinity;
                    let bestScore = Infinity;

                    for (let k = 0; k < TRIALS; k++) {
                        // 1. 性別ごとに分けてシャッフル
                        let boys = unassigned.filter(s => s.gender === 'boy');
                        let girls = unassigned.filter(s => s.gender === 'girl');
                        let mixed = unassigned.filter(s => s.gender !== 'boy' && s.gender !== 'girl');

                        const shuffleArr = (arr) => {
                            let res = [...arr];
                            for (let i = res.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [res[i], res[j]] = [res[j], res[i]];
                            }
                            return res;
                        };
                        
                        let tempGroups = groups.map(g => ({...g, members: [...g.members]}));
                        let currentConflicts = 0;

                        // 2. グループに均等に配る関数 (コンフリクト回避優先)
                        const assignToGroups = (students) => {
                            students.forEach(s => {
                                let minLen = Math.min(...tempGroups.map(g => g.members.length));
                                let candidates = tempGroups.filter(g => g.members.length === minLen);
                                
                                // コンフリクトがない候補を探す
                                let validCandidates = candidates.filter(g => 
                                    !g.members.some(m => s.avoid.includes(m.id) || m.avoid.includes(s.id))
                                );

                                let targetGroup;
                                if (validCandidates.length > 0) {
                                    targetGroup = validCandidates[Math.floor(Math.random() * validCandidates.length)];
                                } else {
                                    // 【最優先：NG回避】人数バランスを崩してでもNGにならない班を探す
                                    let allValidGroups = tempGroups.filter(g => 
                                        !g.members.some(m => s.avoid.includes(m.id) || m.avoid.includes(s.id))
                                    );
                                    if(allValidGroups.length > 0) {
                                        let minValidLen = Math.min(...allValidGroups.map(g => g.members.length));
                                        let bestValidCandidates = allValidGroups.filter(g => g.members.length === minValidLen);
                                        targetGroup = bestValidCandidates[Math.floor(Math.random() * bestValidCandidates.length)];
                                    } else {
                                        // どうやってもNGになる場合は諦めて入れる
                                        targetGroup = candidates[Math.floor(Math.random() * candidates.length)];
                                        currentConflicts++;
                                    }
                                }
                                targetGroup.members.push(s);
                            });
                        };

                        // 順番に配ることで男女を均等化する
                        assignToGroups(shuffleArr(boys));
                        assignToGroups(shuffleArr(girls));
                        assignToGroups(shuffleArr(mixed));

                        // 3. 評価スコア (NG条件抵触には大きなペナルティ)
                        let lengths = tempGroups.map(g => g.members.length);
                        let balancePenalty = Math.max(...lengths) - Math.min(...lengths);
                        let score = (currentConflicts * 1000) + balancePenalty;

                        if (score < bestScore) {
                            bestScore = score;
                            bestGroups = tempGroups;
                            minConflicts = currentConflicts;
                        }
                        
                        // 理想的な状態 (NGなし ＆ 人数差1以内) なら早めに探索打ち切り
                        if (currentConflicts === 0 && balancePenalty <= 1) break;
                    }

                    setGroups(bestGroups);
                    if (minConflicts === 0) {
                        showToast("男女均等で最適な班分けができました！", "success");
                    } else {
                        showToast(`班分け完了（※NG条件を${minConflicts}件 解消できませんでした）`, "warning");
                    }

                } else {
                    if (mode === 'desc') {
                        targets.reverse();
                    }

                    let newGroups = groups.map(g => ({...g, members: [...g.members]}));
                    let gIdx = 0; 

                    targets.forEach(s => {
                        let assigned = false;
                        const startIdx = gIdx;

                        for (let i = 0; i < newGroups.length; i++) {
                            const currentGIdx = (startIdx + i) % newGroups.length;
                            const group = newGroups[currentGIdx];
                            
                            const hasConflict = group.members.some(m => s.avoid.includes(m.id) || m.avoid.includes(s.id));
                            const minMembers = Math.min(...newGroups.map(g => g.members.length));
                            
                            if (!hasConflict && group.members.length <= minMembers + 1) {
                                group.members.push(s);
                                gIdx = (currentGIdx + 1) % newGroups.length; 
                                assigned = true;
                                break;
                            }
                        }

                        if (!assigned) {
                            let minLen = Infinity;
                            let targetGIdx = 0;
                            newGroups.forEach((g, i) => {
                                if(g.members.length < minLen) {
                                    minLen = g.members.length;
                                    targetGIdx = i;
                                }
                            });
                            newGroups[targetGIdx].members.push(s);
                        }
                    });

                    setGroups(newGroups);
                    showToast("順序通りに振り分けました", "success");
                }
            };

            const doPrint = () => handlePrint('print-target', showToast);

            const doExcel = () => {
                const rows = [];
                let maxLen = 0;
                groups.forEach(g => { if(g.members.length > maxLen) maxLen = g.members.length; });
                
                const header = groups.map(g => g.name);
                rows.push(header);
                
                for(let i=0; i<maxLen; i++) {
                    const row = [];
                    groups.forEach(g => {
                        row.push(g.members[i] ? g.members[i].name : "");
                    });
                    rows.push(row);
                }
                
                const ws = XLSX.utils.aoa_to_sheet(rows);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "班分け");
                XLSX.writeFile(wb, "班分け.xlsx");
                showToast("Excelファイルをダウンロードしました", "success");
            };

            return (
                <div className="space-y-4">
                    <ConfirmModal isOpen={!!delGId} onClose={()=>setDelGId(null)} onConfirm={deleteGroup} message="班を削除しますか？メンバーは未所属に戻ります。" />
                    <ConfirmModal isOpen={resetConfirm} onClose={()=>setResetConfirm(false)} onConfirm={resetAll} message="全ての班を削除し、全員を未所属に戻しますか？" />
                    
                    <Card title="グループ分け" action={
                        <div className="flex gap-2">
                                <Button variant="secondary" onClick={doPrint}><Icons.Printer /> 印刷</Button>
                                <Button variant="secondary" onClick={doExcel}><Icons.Download /> Excel</Button>
                        </div>
                    }>
                        <div className="no-print mb-4 p-4 bg-gray-50 rounded border flex flex-col gap-3">
                            <div className="flex gap-2 items-center">
                                <Button variant="secondary" onClick={addGroup} disabled={!canAddGroup} title={!canAddGroup ? "未所属の生徒がいません" : ""}>
                                    <Icons.Plus /> 班追加
                                </Button>
                                <Button variant="danger" onClick={()=>setResetConfirm(true)} disabled={groups.length===0}>
                                    <Icons.Trash /> 全削除
                                </Button>
                                <span className="text-sm text-gray-500 ml-2">※未所属がいる場合のみ班を追加できます</span>
                            </div>
                            
                            <div className="flex gap-2 items-center border-t pt-3">
                                <span className="text-sm font-bold text-gray-700">自動振り分け:</span>
                                <Button variant="ghost" className="text-xs" onClick={()=>autoAssign('asc')} disabled={unassigned.length===0}>名簿順</Button>
                                <Button variant="ghost" className="text-xs" onClick={()=>autoAssign('desc')} disabled={unassigned.length===0}>逆順</Button>
                                <Button variant="ghost" className="text-xs" onClick={()=>autoAssign('random')} disabled={unassigned.length===0}>ランダム（男女均等）</Button>
                            </div>
                        </div>

                        <div id="print-target" className="flex gap-4 overflow-x-auto pb-4 min-h-[400px]">
                            <div className="min-w-[180px] bg-gray-100 p-4 rounded border-2 border-dashed no-print" onDragOver={e=>e.preventDefault()} onDrop={e=>onDrop(e,'un')}>
                                <div className="font-bold text-gray-500 mb-2">未所属 ({unassigned.length})</div>
                                {unassigned.map(s=>(
                                    <div key={s.id} draggable onDragStart={e=>onDrag(e,s.id,'un')} 
                                        className={`p-2 rounded shadow mb-2 text-sm cursor-grab border hover:opacity-80
                                            ${s.gender==='boy' ? 'bg-blue-50 border-blue-200 text-blue-900' : 
                                              s.gender==='girl' ? 'bg-red-50 border-red-200 text-red-900' : 
                                              'bg-white border-transparent'}`}
                                    >
                                        {s.name}
                                    </div>
                                ))}
                            </div>
                            {groups.map(g=>(
                                <div key={g.id} className="min-w-[180px] bg-white border p-4 rounded shadow-sm flex flex-col" onDragOver={e=>e.preventDefault()} onDrop={e=>onDrop(e,g.id)}>
                                    <input className="font-bold border-b mb-2 w-full focus:outline-none focus:border-blue-500" value={g.name} onChange={e=>{
                                        const ng=groups.map(gx => gx.id===g.id ? {...gx, name:e.target.value} : gx); 
                                        setGroups(ng);
                                    }} />
                                    <div className="flex-grow min-h-[50px]">
                                        {g.members.map(s=>(
                                            <div key={s.id} draggable onDragStart={e=>onDrag(e,s.id,g.id)} 
                                                className={`p-2 rounded mb-2 text-sm cursor-grab border hover:opacity-80
                                                    ${s.gender==='boy' ? 'bg-blue-100 border-blue-300 text-blue-900' : 
                                                      s.gender==='girl' ? 'bg-red-100 border-red-300 text-red-900' : 
                                                      'bg-blue-50 border-blue-100'}`}
                                            >
                                                {s.name}
                                            </div>
                                        ))}
                                    </div>
                                    <div className="text-right mt-2 text-xs text-gray-400">{g.members.length}名</div>
                                    <button onClick={()=>setDelGId(g.id)} className="text-red-300 text-right mt-1 no-print hover:text-red-500"><Icons.Trash size={16}/></button>
                                </div>
                            ))}
                        </div>
                    </Card>
                </div>
            );
        };

        // --- 5. 写真ツール (新機能) ---
        const PhotoTool = ({ data, showToast }) => {
            const [photos, setPhotos] = useState({}); // { studentId: dataUrl }
            const [stockPhotos, setStockPhotos] = useState([]); // 写真ストック(最大100枚)
            const [selectedStockIndex, setSelectedStockIndex] = useState(null); // タップ操作用
            
            const [isDragging, setIsDragging] = useState(false);
            const [printCols, setPrintCols] = useState(8);
            const [printOrientation, setPrintOrientation] = useState('portrait'); // 縦横設定
            
            // カメラ用ステート
            const [cameraTarget, setCameraTarget] = useState(null);
            const videoRef = useRef(null);
            const streamRef = useRef(null);

            // 制限設定
            const MAX_STOCK = 100;
            const isNoStudents = data.students.length === 0;
            const isExportDisabled = isNoStudents || Object.keys(photos).length === 0;

            // メモリ解放
            useEffect(() => {
                return () => {
                    if (streamRef.current) streamRef.current.getTracks().forEach(t => t.stop());
                };
            }, []);

            // --- 画像アップロード処理 (ストックエリアへ) ---
            const processFiles = async (files) => {
                const imageFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
                if(imageFiles.length === 0) return;
                
                let availableSlots = MAX_STOCK - stockPhotos.length;
                if (availableSlots <= 0) {
                    return showToast(`ストックの上限(${MAX_STOCK}枚)に達しています`, "error");
                }

                let filesToProcess = imageFiles.slice(0, availableSlots);
                if (imageFiles.length > availableSlots) {
                    showToast(`上限を超えるため、${availableSlots}枚のみ読み込みます`, "warning");
                } else {
                    showToast(`${filesToProcess.length}枚の画像をストックに読み込んでいます...`, "info");
                }
                
                let newStocks = [];
                for (let i = 0; i < filesToProcess.length; i++) {
                    try {
                        const dataUrl = await resizeImage(filesToProcess[i], 1200);
                        newStocks.push(dataUrl);
                    } catch(e) {
                        console.error("画像リサイズエラー:", e);
                    }
                }
                
                setStockPhotos(prev => [...prev, ...newStocks]);
                showToast(`${newStocks.length}枚をストックに追加しました`, "success");
            };

            const onDropFiles = (e) => {
                e.preventDefault(); setIsDragging(false);
                if (e.dataTransfer.files) processFiles(e.dataTransfer.files);
            };

            const handleFileSelect = (e) => {
                if (e.target.files) processFiles(e.target.files);
                e.target.value = ''; // Reset input
            };

            // --- ドラッグ＆ドロップ ＆ タップ配置処理 ---
            const handleDragStartStock = (e, index) => {
                e.dataTransfer.setData("stockIndex", index);
                setSelectedStockIndex(index); // 見た目も選択状態にする
            };

            const handleDropOnStudent = (e, studentId) => {
                e.preventDefault();
                const stockIndexStr = e.dataTransfer.getData("stockIndex");
                if (stockIndexStr === "") return;
                assignPhotoToStudent(parseInt(stockIndexStr), studentId);
            };

            const assignPhotoToStudent = (stockIndex, studentId) => {
                if (stockIndex < 0 || stockIndex >= stockPhotos.length) return;
                
                const photoData = stockPhotos[stockIndex];
                const oldPhoto = photos[studentId];
                
                // ストックから消す
                const newStock = [...stockPhotos];
                newStock.splice(stockIndex, 1);
                
                // 生徒がすでに写真を持っていたら、それをストックに戻す
                if (oldPhoto) {
                    newStock.push(oldPhoto);
                }
                
                setStockPhotos(newStock);
                setPhotos(prev => ({...prev, [studentId]: photoData}));
                setSelectedStockIndex(null); // 選択解除
            };

            const handleStudentClick = (studentId) => {
                if (selectedStockIndex !== null) {
                    assignPhotoToStudent(selectedStockIndex, studentId);
                }
            };

            // --- 既存の写真操作 ---
            const removePhoto = (id) => {
                const oldPhoto = photos[id];
                if (!oldPhoto) return;
                
                const newPhotos = {...photos};
                delete newPhotos[id];
                setPhotos(newPhotos);

                // ゴミ箱に捨てた写真はストックに戻す（上限未満の場合のみ）
                if (stockPhotos.length < MAX_STOCK) {
                    setStockPhotos(prev => [...prev, oldPhoto]);
                    showToast("写真をストックに戻しました", "info");
                } else {
                    showToast("取り外した写真はストック上限のため破棄されました", "warning");
                }
            };

            const rotatePhoto = async (id) => {
                if (!photos[id]) return;
                try {
                    const rotated = await rotateImage(photos[id]);
                    setPhotos(prev => ({...prev, [id]: rotated}));
                } catch(e) {
                    showToast("回転に失敗しました", "error");
                }
            };

            // --- カメラ機能 ---
            const openCamera = async (studentId) => {
                setCameraTarget(studentId);
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                    streamRef.current = stream;
                    if (videoRef.current) videoRef.current.srcObject = stream;
                } catch(err) {
                    showToast("カメラの起動に失敗しました。権限を確認してください。", "error");
                    setCameraTarget(null);
                }
            };

            const takePhoto = () => {
                if (!videoRef.current || !cameraTarget) return;
                const video = videoRef.current;
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                canvas.getContext('2d').drawImage(video, 0, 0);
                
                const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                setPhotos(prev => ({...prev, [cameraTarget]: dataUrl}));
                closeCamera();
            };

            const closeCamera = () => {
                if (streamRef.current) streamRef.current.getTracks().forEach(t => t.stop());
                setCameraTarget(null);
            };

            // --- ZIPダウンロード ---
            const downloadZip = async () => {
                if (isExportDisabled) return;

                showToast("ZIPファイルを作成中です...", "info");
                try {
                    const zip = new JSZip();
                    data.students.forEach((s, idx) => {
                        if (photos[s.id]) {
                            const blob = dataURLtoBlob(photos[s.id]);
                            // ファイル名: 学年組_No_氏名.jpg
                            const noStr = String(idx + 1).padStart(2, '0');
                            const prefix = data.settings.gradeClass ? `${data.settings.gradeClass}_` : '';
                            const filename = `${prefix}${noStr}_${s.name}.jpg`;
                            zip.file(filename, blob);
                        }
                    });
                    
                    const content = await zip.generateAsync({type:"blob"});
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `クラス写真_${data.settings.gradeClass || '未設定'}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showToast("ZIPダウンロードが完了しました", "success");
                } catch(err) {
                    showToast("ZIP作成中にエラーが発生しました", "error");
                    console.error(err);
                }
            };

            return (
                <div className="space-y-6">
                    {/* カメラモーダル */}
                    {cameraTarget && (
                        <div className="modal-overlay z-[3000]">
                            <div className="bg-black p-4 rounded-xl shadow-2xl">
                                <video ref={videoRef} autoPlay playsInline className="max-h-[70vh] rounded bg-gray-900 mx-auto" />
                                <div className="mt-4 flex justify-center gap-4">
                                    <Button variant="secondary" onClick={closeCamera}>キャンセル</Button>
                                    <Button variant="primary" onClick={takePhoto} className="px-8 py-3"><Icons.Camera /> 撮影する</Button>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="bg-orange-50 border border-orange-200 text-orange-800 p-4 rounded-lg shadow-sm flex gap-3 no-print items-start">
                        <Icons.AlertOctagon size={24} className="flex-shrink-0 mt-1" />
                        <div className="text-sm">
                            <p className="font-bold text-base mb-1">【重要】写真データはブラウザ内に保存されません！</p>
                            <p>プライバシー保護および動作の安定化（メモリオーバー防止）のため、<b>写真はページを再読み込みしたり、他の作業をして戻ると消去されます。</b><br/>作業が完了したら、必ずページ下部のボタンから<b>ZIPダウンロード</b>または<b>PDF印刷</b>を行ってください。</p>
                        </div>
                    </div>

                    <div className="no-print">
                        <Card title={`1. 写真ストック (${stockPhotos.length}/${MAX_STOCK}枚)`} subtitle="ここに画像をドロップしてストックし、下の名簿枠へ「ドラッグ＆ドロップ」または「タップして配置」します。">
                            {/* 一括アップロードエリア */}
                            <div className={`drop-zone p-6 rounded-xl text-center mb-4 cursor-pointer
                                ${isDragging ? 'dragover' : 'bg-gray-50'}`}
                                onDragOver={e => { e.preventDefault(); setIsDragging(true); }}
                                onDragLeave={() => setIsDragging(false)}
                                onDrop={onDropFiles}
                                onClick={() => document.getElementById('fileUpload').click()}
                            >
                                <Icons.UploadCloud size={40} className="mx-auto text-blue-400 mb-2" />
                                <p className="font-bold text-gray-700">ここに複数枚の画像ファイルをドロップ</p>
                                <p className="text-xs text-gray-500 mt-1">追加した写真は自動で軽量化され、下のストックエリアに並びます。</p>
                                <input id="fileUpload" type="file" multiple accept="image/*" className="hidden" onChange={handleFileSelect} />
                            </div>

                            {/* ストックグリッド */}
                            {stockPhotos.length > 0 && (
                                <div className="p-3 bg-blue-50/50 rounded-lg border border-blue-100">
                                    <div className="flex items-center justify-between mb-2">
                                        <p className="text-sm font-bold text-blue-800">
                                            {selectedStockIndex !== null ? '👇 配置したい児童の枠をタップしてください' : '👉 写真をドラッグ、またはタップして選択'}
                                        </p>
                                        {selectedStockIndex !== null && (
                                            <Button variant="secondary" className="text-xs py-1" onClick={() => setSelectedStockIndex(null)}>選択解除</Button>
                                        )}
                                    </div>
                                    <div className="flex gap-3 overflow-x-auto pb-2 p-1 min-h-[120px]">
                                        {stockPhotos.map((dataUrl, i) => (
                                            <div 
                                                key={i} 
                                                draggable 
                                                onDragStart={(e) => handleDragStartStock(e, i)}
                                                onClick={() => setSelectedStockIndex(i === selectedStockIndex ? null : i)}
                                                className={`relative w-20 h-28 flex-shrink-0 cursor-grab rounded overflow-hidden border-2 transition-all 
                                                    ${selectedStockIndex === i ? 'border-blue-500 scale-105 shadow-md z-10' : 'border-gray-200 hover:border-gray-400'}`}
                                            >
                                                <img src={dataUrl} className="w-full h-full object-cover pointer-events-none" />
                                                {selectedStockIndex === i && (
                                                    <div className="absolute top-0 right-0 bg-blue-500 text-white text-[10px] px-1 font-bold rounded-bl shadow">
                                                        選択中
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </Card>
                    </div>

                    <Card title="2. 児童の写真割り当て" subtitle={isNoStudents ? "※名簿タブで生徒を登録してください" : "プレビュー用グリッド"}>
                        {/* 写真グリッド (印刷プレビュー対象) */}
                        <div id="print-target" className="p-4 bg-white print:p-0">
                            <div className={`photo-grid grid gap-4 grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 print:grid-cols-${printCols}`}>
                                {data.students.map((s, idx) => {
                                    const hasPhoto = !!photos[s.id];
                                    const isTargetMode = selectedStockIndex !== null;
                                    
                                    return (
                                        <div 
                                            key={s.id} 
                                            className={`photo-card relative group flex flex-col h-full bg-white border rounded overflow-hidden shadow-sm transition-all
                                                ${isTargetMode ? 'ring-2 ring-blue-300 ring-offset-1 cursor-pointer hover:bg-blue-50 hover:ring-blue-500' : 'border-gray-200'}`}
                                            onDragOver={e => e.preventDefault()}
                                            onDrop={e => handleDropOnStudent(e, s.id)}
                                            onClick={() => handleStudentClick(s.id)}
                                        >
                                            <div className="relative w-full pt-[133%] bg-gray-100 flex-shrink-0"> {/* 3:4 アスペクト比 */}
                                                {hasPhoto ? (
                                                    <img src={photos[s.id]} alt={s.name} className="absolute top-0 left-0 w-full h-full object-cover" />
                                                ) : (
                                                    <div className="absolute top-0 left-0 w-full h-full flex flex-col items-center justify-center text-gray-300">
                                                        <Icons.Image size={32} />
                                                        {isTargetMode && <span className="text-xs font-bold text-blue-400 mt-2">ここへ配置</span>}
                                                    </div>
                                                )}
                                                
                                                {/* マウスオーバー時（またはスマホタッチ時）の操作レイヤー */}
                                                <div className="no-print absolute top-0 left-0 w-full h-full bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex flex-col items-center justify-center gap-2">
                                                    {!hasPhoto ? (
                                                        <button onClick={(e)=>{e.stopPropagation(); openCamera(s.id);}} className="bg-white p-2 rounded-full text-blue-600 hover:scale-110 transition"><Icons.Camera size={20}/></button>
                                                    ) : (
                                                        <>
                                                            <button onClick={(e)=>{e.stopPropagation(); rotatePhoto(s.id);}} className="bg-white p-2 rounded-full text-gray-700 hover:scale-110 transition" title="90度回転"><Icons.RotateCw size={20}/></button>
                                                            <button onClick={(e)=>{e.stopPropagation(); removePhoto(s.id);}} className="bg-white p-2 rounded-full text-red-500 hover:scale-110 transition" title="外す (ストックに戻す)"><Icons.Trash size={20}/></button>
                                                        </>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="p-2 text-center border-t bg-gray-50 flex-grow flex flex-col justify-center">
                                                <div className="photo-no">{idx + 1}</div>
                                                <div className="photo-name text-gray-800 leading-tight">{s.name || '未設定'}</div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>

                        {/* 下部アクションバー */}
                        <div className="no-print sticky bottom-4 mt-8 bg-white border shadow-xl p-4 rounded-xl flex flex-wrap justify-between items-center gap-4 z-40">
                            <div className="flex items-center gap-2 text-sm text-gray-600 font-bold">
                                登録済み: {Object.keys(photos).length} / {data.students.length}名
                            </div>
                            <div className="flex flex-wrap items-center gap-3">
                                <div className="flex items-center gap-2 bg-gray-50 px-3 py-1 rounded border">
                                    <span className="text-xs font-bold text-gray-600">レイアウト設定:</span>
                                    <select className="border rounded text-sm p-1 font-bold" 
                                        value={`${printOrientation}-${printCols}`} 
                                        onChange={e => {
                                            const [ori, cols] = e.target.value.split('-');
                                            setPrintOrientation(ori);
                                            setPrintCols(parseInt(cols));
                                        }}>
                                        <optgroup label="縦向き (A4)">
                                            <option value="portrait-4">縦 4列 (大きめ)</option>
                                            <option value="portrait-6">縦 6列 (標準大)</option>
                                            <option value="portrait-8">縦 8列 (標準)</option>
                                            <option value="portrait-12">縦 12列 (小さめ)</option>
                                        </optgroup>
                                        <optgroup label="横向き (A4)">
                                            <option value="landscape-4">横 4列 (かなり大きめ)</option>
                                            <option value="landscape-6">横 6列 (大きめ)</option>
                                            <option value="landscape-8">横 8列 (標準大)</option>
                                            <option value="landscape-12">横 12列 (標準)</option>
                                        </optgroup>
                                    </select>
                                </div>
                                <Button variant="secondary" onClick={() => handlePrint('print-target', showToast, { isPhotoPrint: true, orientation: printOrientation })} disabled={isExportDisabled} title={isExportDisabled ? "名簿・写真データを追加してください" : ""}>
                                    <Icons.Printer /> PDF(印刷)作成
                                </Button>
                                <Button variant="primary" onClick={downloadZip} disabled={isExportDisabled} title={isExportDisabled ? "名簿・写真データを追加してください" : ""}>
                                    <Icons.Download /> まとめてZIP保存
                                </Button>
                            </div>
                        </div>
                    </Card>
                </div>
            );
        };

        // --- メインアプリ ---
        const App = () => {
            const [data, setData] = useState(() => {
                const s = localStorage.getItem('classToolDataV2');
                return s ? JSON.parse(s) : { settings:{school:'', teacher:'', gradeClass:''}, students:[], seatConfig:{rows:5, cols:6}, dutyConfig:{jobs:[], duration:15, type:'week'}, clubConfig:{clubs:[]} };
            });
            const [tab, setTab] = useState('students');
            const [appState, setAppState] = useState(() => {
                const s = localStorage.getItem('classToolAppState');
                return s ? JSON.parse(s) : { isLocked: false, lockPass: null }; 
            });

            // --- トースト管理 ---
            const [toasts, setToasts] = useState([]);
            const showToast = useCallback((message, type = 'info') => {
                const id = Date.now();
                setToasts(prev => [...prev, { id, message, type }]);
                setTimeout(() => {
                    setToasts(prev => prev.filter(t => t.id !== id));
                }, 3000);
            }, []);

            useEffect(() => {
                localStorage.setItem('classToolDataV2', JSON.stringify(data));
            }, [data]);

            useEffect(() => {
                localStorage.setItem('classToolAppState', JSON.stringify(appState));
            }, [appState]);

            const resetAllData = () => {
                const initialData = { settings:{school:'', teacher:'', gradeClass:''}, students:[], seatConfig:{rows:5, cols:6}, dutyConfig:{jobs:[], duration:15, type:'week'}, clubConfig:{clubs:[]} };
                const initialAppState = { isLocked: false, lockPass: null };
                
                setData(initialData);
                setAppState(initialAppState);
                localStorage.removeItem('classToolDataV2');
                localStorage.removeItem('classToolAppState');
                
                showToast("全てのデータを初期化しました", "success");
            };

            return (
                <div className="min-h-screen pb-20 relative">
                    <ToastContainer toasts={toasts} />
                    
                    <header className="bg-white shadow-sm border-b sticky top-0 z-50 no-print">
                        <div className="max-w-7xl mx-auto px-4 py-3 flex flex-wrap justify-between items-center gap-2">
                            <h1 className="text-xl font-bold text-gray-800 flex items-center gap-2"><Icons.Smile /> クラス管理ツール Pro</h1>
                            <div className="flex gap-1 overflow-x-auto pb-1 sm:pb-0">
                                <Button onClick={()=>setTab('students')} variant={tab==='students'?'primary':'ghost'}><Icons.Users /> 名簿</Button>
                                <Button onClick={()=>setTab('seats')} variant={tab==='seats'?'primary':'ghost'}><Icons.Grid /> 席替</Button>
                                <Button onClick={()=>setTab('duties')} variant={tab==='duties'?'primary':'ghost'}><Icons.Calendar /> 当番</Button>
                                <Button onClick={()=>setTab('clubs')} variant={tab==='clubs'?'primary':'ghost'}><Icons.Layers /> 班</Button>
                                {/* 写真タブ追加 */}
                                <Button onClick={()=>setTab('photos')} variant={tab==='photos'?'primary':'ghost'} className="border-l border-gray-200 ml-1 pl-3 text-blue-600"><Icons.Image /> 写真</Button>
                            </div>
                        </div>
                    </header>

                    <main className="max-w-7xl mx-auto px-4 py-6">
                        <div className="hidden print:block text-center mb-4" id="print-header">
                            <h1 className="text-2xl font-bold">{data.settings.school} {data.settings.gradeClass}</h1>
                            <div className="text-right">担任: {data.settings.teacher}</div>
                        </div>
                        {tab==='students' && (
                            <StudentRegistration 
                                data={data} 
                                setData={setData}
                                isLocked={appState.isLocked}
                                setIsLocked={(val) => setAppState(prev => ({...prev, isLocked: val}))}
                                lockPass={appState.lockPass}
                                setLockPass={(val) => setAppState(prev => ({...prev, lockPass: val}))}
                                resetAll={resetAllData} 
                                showToast={showToast}
                            />
                        )}
                        {tab==='seats' && <SeatingTool data={data} setData={setData} showToast={showToast} />}
                        {tab==='duties' && <DutyTool data={data} setData={setData} showToast={showToast} />}
                        {tab==='clubs' && <ClubTool data={data} setData={setData} showToast={showToast} />}
                        {/* 写真ツール表示 */}
                        {tab==='photos' && <PhotoTool data={data} showToast={showToast} />}
                    </main>
                    
                    <footer className="no-print fixed bottom-0 w-full bg-white border-t py-2 text-center text-xs text-gray-400">
                        自動保存中（※写真データは保存されません）
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
    <script>
        // オフライン対応（PWA）の設定
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('Service Worker Registered!', reg))
                    .catch(err => console.log('SW Registration Failed', err));
            });
        }
    </script>
</body>
</html>

