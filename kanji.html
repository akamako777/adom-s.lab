<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI漢字ドリル作成機 - 全学年対応</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- SheetJS (Excel出力用) -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>

    <!-- Google Fonts -->
    <!-- Zen Maru Gothic: 丸ゴシック -->
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Yuji Syuku: 教科書体・習字風 -->
    <link href="https://fonts.googleapis.com/css2?family=Yuji+Syuku&display=swap" rel="stylesheet">
    <!-- Noto Serif JP: 明朝体 -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    <!-- Kaisei Decol: 可愛らしい明朝 -->
    <link href="https://fonts.googleapis.com/css2?family=Kaisei+Decol:wght@400;700&display=swap" rel="stylesheet">
    <!-- Zen Kurenaido: 手書き風 -->
    <link href="https://fonts.googleapis.com/css2?family=Zen+Kurenaido&display=swap" rel="stylesheet">
    <!-- BIZ UDMincho & Gothic: ユニバーサルデザイン (モリサワ) -->
    <link href="https://fonts.googleapis.com/css2?family=BIZ+UDPGothic:wght@400;700&family=BIZ+UDPMincho:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* 基本設定 */
        body {
            font-family: 'Zen Maru Gothic', sans-serif;
            background-color: #f3f4f6;
            color: #1f2937;
        }

        /* 縦書き設定 */
        .tategaki {
            writing-mode: vertical-rl;
            text-orientation: upright;
            font-feature-settings: "vhal" 1; /* 縦書き用文字詰め */
        }

        /* 十字リーダー（点線） */
        .guide-lines {
            position: relative;
        }
        .guide-lines::before {
            content: '';
            position: absolute;
            top: 0; bottom: 0; left: 50%;
            border-left: 1px dashed #d1d5db; /* gray-300 */
            z-index: 0;
            pointer-events: none;
        }
        .guide-lines::after {
            content: '';
            position: absolute;
            left: 0; right: 0; top: 50%;
            border-top: 1px dashed #d1d5db; /* gray-300 */
            z-index: 0;
            pointer-events: none;
        }
        
        /* 画面表示用の印刷エリアスタイル */
        .print-area {
            transform-origin: center top;
        }
        
        @media print {
            .no-print { display: none !important; }
        }
        
        /* アニメーション */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;
        
        // --- Icon Components ---
        const IconBase = ({ children, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );
        const BookOpen = (props) => (<IconBase {...props}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z" /><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z" /></IconBase>);
        const Sparkles = (props) => (<IconBase {...props}><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z" /></IconBase>);
        const Settings = (props) => (<IconBase {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.72l-.15.1a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.72l.15-.1a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" /><circle cx="12" cy="12" r="3" /></IconBase>);
        const Printer = (props) => (<IconBase {...props}><polyline points="6 9 6 2 18 2 18 9" /><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2" /><rect width="12" height="8" x="6" y="14" /></IconBase>);
        const PenTool = (props) => (<IconBase {...props}><path d="m12 19 7-7 3 3-7 7-3-3z" /><path d="m18 13-1.5-7.5L2 2l3.5 14.5L13 18l5-5z" /><path d="m2 2 7.586 7.586" /><circle cx="11" cy="11" r="2" /></IconBase>);
        const LayoutTemplate = (props) => (<IconBase {...props}><rect width="18" height="7" x="3" y="3" rx="1" /><rect width="9" height="7" x="3" y="14" rx="1" /><rect width="5" height="7" x="16" y="14" rx="1" /></IconBase>);
        const ZoomIn = (props) => (<IconBase {...props}><circle cx="11" cy="11" r="8" /><line x1="21" y1="21" x2="16.65" y2="16.65" /><line x1="11" y1="8" x2="11" y2="14" /><line x1="8" y1="11" x2="14" y2="11" /></IconBase>);
        const FileText = (props) => (<IconBase {...props}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" /><polyline points="14 2 14 8 20 8" /></IconBase>);
        const Save = (props) => (<IconBase {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" /><polyline points="17 21 17 13 7 13 7 21" /><polyline points="7 3 7 8 15 8" /></IconBase>);
        const Download = (props) => (<IconBase {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" y1="15" x2="12" y2="3" /></IconBase>);
        const Trash2 = (props) => (<IconBase {...props}><polyline points="3 6 5 6 21 6" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /><line x1="10" y1="11" x2="10" y2="17" /><line x1="14" y1="11" x2="14" y2="17" /></IconBase>);
        const Type = (props) => (<IconBase {...props}><polyline points="4 7 4 4 20 4 20 7" /><line x1="9" y1="20" x2="15" y2="20" /><line x1="12" y1="4" x2="12" y2="20" /></IconBase>);
        const BrainCircuit = (props) => (<IconBase {...props}><path d="M12 5a3 3 0 1 0-5.997.125 4 4 0 0 0-2.526 5.77 4 4 0 0 0 .556 6.588A4 4 0 1 0 12 18Z" /><path d="M12 5a3 3 0 1 1 5.997.125 4 4 0 0 1 2.526 5.77 4 4 0 0 1-.556 6.588A4 4 0 1 1 12 18Z" /><path d="M15 13a4.5 4.5 0 0 1-3-4 4.5 4.5 0 0 1-3 4" /><path d="M17.599 6.5a3 3 0 0 0 .399-1.375" /><path d="M6.003 5.125A3 3 0 0 0 6.401 6.5" /><path d="M3.477 10.896a4 4 0 0 1 .585-.396" /><path d="M19.938 10.5a4 4 0 0 1 .585.396" /><path d="M6 18a4 4 0 0 1-1.97-3.284" /><path d="M17.97 14.716A4 4 0 0 1 18 18" /></IconBase>);
        const Key = (props) => (<IconBase {...props}><path d="m21 2-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0 3 3L22 7l-3-3m-3.5 3.5L19 4" /></IconBase>);
        const ChevronDown = (props) => (<IconBase {...props}><path d="m6 9 6 6 6-6"/></IconBase>);
        const ChevronUp = (props) => (<IconBase {...props}><path d="m18 15-6-6-6 6"/></IconBase>);
        const Eye = (props) => (<IconBase {...props}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></IconBase>);
        const EyeOff = (props) => (<IconBase {...props}><path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" x2="22" y1="2" y2="22"/></IconBase>);
        const ExternalLink = (props) => (<IconBase {...props}><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></IconBase>);

        // Gemini API設定 (Canvas環境用のデフォルト空キー)
        const DEFAULT_API_KEY = ""; 

        // フォント定義
        const FONT_OPTIONS = [
            { id: 'Yuji Syuku', name: '教科書体風 (Yuji)', family: "'Yuji Syuku', serif" },
            { id: 'BIZ UDPMincho', name: 'UD明朝 (BIZ)', family: "'BIZ UDPMincho', serif" },
            { id: 'BIZ UDPGothic', name: 'UDゴシック (BIZ)', family: "'BIZ UDPGothic', sans-serif" },
            { id: 'Zen Maru Gothic', name: '丸ゴシック (Zen)', family: "'Zen Maru Gothic', sans-serif" },
            { id: 'Noto Serif JP', name: '明朝体 (Noto)', family: "'Noto Serif JP', serif" },
            { id: 'Kaisei Decol', name: 'デコール (Kaisei)', family: "'Kaisei Decol', serif" },
            { id: 'Zen Kurenaido', name: '手書き風 (Kurenaido)', family: "'Zen Kurenaido', sans-serif" },
        ];

        const STORAGE_KEY = 'kanji_drill_saves_v1';
        const API_KEY_STORAGE_KEY = 'kanji_drill_api_key_v1';
        const MAX_SAVES = 50;

        // --- 確認用モーダルコンポーネント ---
        const ConfirmModal = ({ isOpen, onClose, onConfirm, message, confirmText = "実行する", confirmColor = "bg-red-500" }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 no-print" onClick={onClose}>
                    <div className="bg-white rounded-xl p-6 shadow-2xl max-w-sm w-full animate-fade-in mx-4" onClick={e => e.stopPropagation()}>
                        <h3 className="text-lg font-bold mb-2 flex items-center gap-2 text-gray-800">
                            確認
                        </h3>
                        <p className="text-gray-600 mb-6 whitespace-pre-wrap text-sm">{message}</p>
                        <div className="flex justify-end gap-3">
                            <button className="bg-gray-200 text-gray-700 px-4 py-2 rounded text-sm font-bold hover:bg-gray-300 transition-colors" onClick={onClose}>キャンセル</button>
                            <button className={`${confirmColor} text-white px-4 py-2 rounded text-sm font-bold hover:opacity-80 transition-opacity`} onClick={() => { onConfirm(); onClose(); }}>{confirmText}</button>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            // --- API Key Management State ---
            const [userApiKey, setUserApiKey] = useState('');
            const [isApiKeyOpen, setIsApiKeyOpen] = useState(false);
            const [showApiKeyChar, setShowApiKeyChar] = useState(false);

            // --- State ---
            const [rawText, setRawText] = useState("春(はる)春(はる)春(はる)春(はる)の(の)風(かぜ)\n美(び)美(び)美(び)美(うつく)し(し)い(い)\n走(そう)走(そう)走(そう)走(はし)る(る)\n学(がく)学(がく)学(がく)学(がっ)校(こう)");
            const [parsedLines, setParsedLines] = useState([]);
            
            // AI生成用State
            const [aiMode, setAiMode] = useState('auto'); // 'auto' | 'manual'
            const [targetGrade, setTargetGrade] = useState('小3');
            const [drillTheme, setDrillTheme] = useState('');
            const [targetKanji, setTargetKanji] = useState('');
            const [drillPattern, setDrillPattern] = useState('half'); 
            // 'all' | 'half' | 'mix' | 'idiom_focus' | 'sentence_focus' | 'teacher_input'

            // 用紙・レイアウト設定
            const [orientation, setOrientation] = useState('portrait');
            const [rows, setRows] = useState(8);
            const [cols, setCols] = useState(6);
            const [title, setTitle] = useState("漢字練習");
            const [showGuide, setShowGuide] = useState(true);
            const [showRubyText, setShowRubyText] = useState(true);
            const [showKanjiText, setShowKanjiText] = useState(true);
            const [mode, setMode] = useState('trace'); 
            const [fontFamily, setFontFamily] = useState(FONT_OPTIONS[0].family);
            
            const [isGenerating, setIsGenerating] = useState(false);
            const [errorMsg, setErrorMsg] = useState("");
            
            // 保存データ
            const [savedDrills, setSavedDrills] = useState([]);
            
            // プレビュー用ズーム
            const [zoom, setZoom] = useState(0.8);

            // モーダル制御用State
            const [deleteTargetId, setDeleteTargetId] = useState(null);
            const [loadTargetDrill, setLoadTargetDrill] = useState(null);

            // 初期ロード
            useEffect(() => {
                // ドリルデータのロード
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    try {
                        setSavedDrills(JSON.parse(saved));
                    } catch (e) {
                        console.error("Save data parse error", e);
                    }
                }
                
                // APIキーのロード
                const storedKey = localStorage.getItem(API_KEY_STORAGE_KEY);
                if (storedKey) {
                    setUserApiKey(storedKey);
                    // キーがあれば閉じておく、なければ目立たせるために開くのも手だが、
                    // 初期状態は閉じておき、ユーザーが必要なら開くUXにする
                    setIsApiKeyOpen(false); 
                } else {
                    // キーがない場合、初回だけアピールとして開く
                    setIsApiKeyOpen(true);
                }
            }, []);

            // APIキー更新ハンドラ
            const handleApiKeyChange = (e) => {
                const newKey = e.target.value;
                setUserApiKey(newKey);
                localStorage.setItem(API_KEY_STORAGE_KEY, newKey);
            };

            // --- Constants for Layout (A4) ---
            const PADDING = 10; // mm (はみ出し防止のため10mmを維持)
            
            const paperSize = useMemo(() => {
                if (orientation === 'portrait') {
                    return { width: 210, height: 297 };
                } else {
                    return { width: 297, height: 210 };
                }
            }, [orientation]);

            const CONTENT_WIDTH = paperSize.width - (PADDING * 2);
            const HEADER_HEIGHT = 14; 
            const GRID_AREA_HEIGHT = paperSize.height - (PADDING * 2) - HEADER_HEIGHT - 5;

            // --- Layout Calculations ---
            const layoutStyles = useMemo(() => {
                const colWidth = CONTENT_WIDTH / cols;
                const cellHeight = GRID_AREA_HEIGHT / rows;
                
                const charAreaWidth = colWidth * 0.75;
                const charDimension = Math.min(charAreaWidth, cellHeight);
                const rubyAreaWidth = colWidth * 0.25;
                
                const maxRubySizeBasedOnHeight = cellHeight * 0.45;
                const rubyDimension = Math.min(rubyAreaWidth, maxRubySizeBasedOnHeight);

                return {
                    colWidth: `${colWidth}mm`,
                    cellHeight: `${cellHeight}mm`,
                    charFontSize: `${charDimension * 0.9}mm`,
                    rubyFontSize: `${rubyDimension * 0.9}mm`, 
                    rubyWidth: '25%',
                    charWidth: '75%',
                };
            }, [rows, cols, paperSize]);

            // --- Gemini API Logic (Hybrid Authentication) ---
            const callGemini = async (prompt) => {
                // ユーザー入力キーがあればそれを使用、なければCanvasデフォルト(空)を使用
                const finalApiKey = userApiKey.trim() || DEFAULT_API_KEY;
                
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${finalApiKey}`,
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }]
                        })
                    }
                );
                
                const data = await response.json();
                
                // エラーハンドリング強化
                if (data.error) {
                    if (data.error.code === 400 && data.error.message.includes('API key')) {
                        // APIキー関連のエラーの場合、ユーザーに設定を開くよう促す
                        setIsApiKeyOpen(true);
                        throw new Error("APIキーが無効または設定されていません。左上の設定から正しいキーを入力してください。");
                    }
                    throw new Error(data.error.message);
                }
                
                return data.candidates[0].content.parts[0].text.trim();
            };

            // ルビ振り（既存）
            const generateRuby = async () => {
                if (!rawText.trim()) return;
                setIsGenerating(true);
                setErrorMsg("");

                try {
                    const prompt = `
                        あなたは日本の国語教師です。以下のテキストを、漢字練習用のマス目に入れるために分解してください。
                        
                        重要ルール:
                        1. すべての文字を「文字(ルビ)」の形式に変換してください。
                        2. 漢字には正しい読み仮名を振ってください。
                        3. 【重要】ひらがな・カタカナにも、その文字自身をルビとして振ってください（例: 「は(は)」「し(し)」）。
                        4. 句読点（、。）も「、(、)」のように変換してください。
                        5. 【重要】不必要な改行は入れないでください。入力テキストの改行のみを維持してください。一文字ごとの改行は禁止です。
                        
                        入力テキスト:
                        ${rawText}
                    `;
                    const result = await callGemini(prompt);
                    setRawText(result);
                } catch (err) {
                    console.error("AI Generation Error:", err);
                    setErrorMsg(err.message || "AI生成に失敗しました。再試行してください。");
                } finally {
                    setIsGenerating(false);
                }
            };

            // ドリル自動生成
            const autoGenerateDrill = async () => {
                setIsGenerating(true);
                setErrorMsg("");

                try {
                    const totalCols = cols; 
                    let specificInstruction = "";
                    let patternInstruction = ""; // 構成パターン用の指示
                    let autoTitle = "";

                    // 構成パターンのロジック (修正: 6パターンに対応)
                    switch (drillPattern) {
                        case 'all': // 1. 単漢字のみ
                            patternInstruction = "各列の構成: 指定された漢字のみを反復して埋めてください。熟語や送り仮名は含めず、その漢字一文字だけを繰り返します。";
                            break;
                            
                        case 'half': // 2. 基本 (既存)
                            patternInstruction = `
                                各列の構成ルール（厳守）:
                                1. 列の前半50%は、「単漢字」の反復にしてください。
                                2. 列の後半50%は、その漢字を使った「熟語」の反復にしてください。
                                3. 重要: 同じ熟語をできるだけ2回以上繰り返してください（例: 春分 春分）。
                                4. 文章は禁止です。
                                5. マスが余る場合は、熟語をさらに繰り返して埋めてください。
                            `;
                            break;

                        case 'idiom_focus': // 3. 新規: 熟語重視（語彙力）
                            patternInstruction = `
                                各列の構成ルール（厳守）:
                                1. 最初の1マスだけ「単漢字」を入れてください。
                                2. 残りのマスは、全てその漢字を使った「熟語（2文字以上）」で埋めてください。
                                3. 重要: できるだけ多くの種類の熟語を使って、語彙を増やす練習にしてください（例: 春分、立春、新春、春風...）。
                                4. 1つの熟語は1回ずつで構いません。とにかく種類を多く出してください。
                                5. 全体として1列の文字数（${rows}文字）に収まるように調整してください。
                                6. もしネタ切れでマスが余る場合は、最初に出した熟語をもう一度繰り返して埋めてください。
                            `;
                            break;

                        case 'mix': // 4. 応用 (既存: mix)
                            patternInstruction = `
                                各列の構成ルール（厳守）:
                                1. まず、その漢字の「単漢字」を数回繰り返します。
                                2. 次に、その漢字を使った「熟語（2文字以上）」を入れます。同じ熟語を2回繰り返してください（例: 春分 春分）。
                                3. 最後に、その漢字を使った「短い文（主語＋述語）」を入れます。
                                4. 重要: 熟語と短文は混ぜずに、順番に配置してください。
                                5. 全体として1列の文字数（${rows}文字）に収まるように調整してください。
                                6. マスが余る場合は、単漢字に戻って繰り返してください。
                            `;
                            break;
                            
                        case 'sentence_focus': // 5. 新規: 実践重視（短文多め）
                            patternInstruction = `
                                各列の構成ルール（厳守）:
                                1. 最初の1マスだけ「単漢字」を入れてください。
                                2. 次に、その漢字を使った「熟語」を1種類だけ（2文字程度）入れてください。
                                3. 残りのスペースは、その漢字を使った「短い文（主語＋述語）」で埋めてください。
                                4. 文脈の中で漢字を使う練習を重視してください。
                                5. 全体として1列の文字数（${rows}文字）に収まるように調整してください。
                                6. マスが余る場合は、同じ文を繰り返すか、別の文を入れて埋めてください。
                            `;
                            break;

                        case 'teacher_input': // 6. 新規: 先生入力（入力順に配置）
                             patternInstruction = `
                                各列の構成ルール（厳守）:
                                1. 入力されたテキストを、**登場順序を変えずに**そのまま配置してください。
                                2. AIによる勝手な熟語の追加や削除は禁止です。入力された内容のみを使ってください。
                                3. 1列の文字数（${rows}文字）に収まるように改行を入れて調整してください。
                                4. 入力内容が短くマスが余る場合は、入力内容を最初から繰り返して埋めてください。
                            `;
                            break;

                        default:
                            patternInstruction = "各列の構成: 単漢字と熟語をバランスよく入れてください。マスが余ったら繰り返してください。";
                            break;
                    }

                    let gradeSpecificPrompt = "";
                    if (targetGrade === '小1') {
                        gradeSpecificPrompt = "★重要★ 対象は小学1年生です。まだ漢字を習っていない場合や、ひらがなの練習が必要な場合は、無理に漢字を使わず「ひらがなの単語」や「ひらがな一文字（あ、い、う...）」の練習を作成してください。";
                    }

                    if (targetKanji.trim()) {
                        // 先生入力モードの場合の特別な分岐
                        if (drillPattern === 'teacher_input') {
                             specificInstruction = `
                                先生が入力したテキスト: ${targetKanji}
                                
                                指示:
                                1. 上記の「先生が入力したテキスト」の内容を、一切変更せず、順番通りにマス目に配置してください。
                                2. 単漢字、熟語、短文など、入力された形式に合わせて適切にルビを振ってください（例: 赤(あか)ちゃん(ちゃん)）。
                                3. 1列の文字数は${rows}文字以下になるように改行コードを入れてください。
                                4. ${gradeSpecificPrompt}
                            `;
                            autoTitle = `${targetGrade}漢字ドリル - 先生入力`;
                        } else {
                            // 通常の生成モード
                            specificInstruction = `
                                ユーザー指定の「使用する漢字・熟語」: ${targetKanji}
                                
                                指示:
                                1. 指定された漢字や熟語を使って、${totalCols}列分の練習データを作成してください。
                                2. 指定された内容が${totalCols}個より少ない場合は、同じ漢字を別の列で使っても構いません。
                                3. 可能な限り、同じ漢字でも「音読み」と「訓読み」の両方を練習できるように構成してください（例: 生(せい) 生(い)きる）。
                                4. ${patternInstruction}
                                5. 1列の文字数は${rows}文字程度になるように調整し、縦のマスを埋めてください。
                                6. ${gradeSpecificPrompt}
                            `;
                            autoTitle = `${targetGrade}漢字練習 - ${targetKanji.slice(0, 5)}...`;
                        }
                    } else if (drillTheme.trim()) {
                        specificInstruction = `
                            テーマ: ${drillTheme}
                            
                            指示:
                            1. テーマ「${drillTheme}」から連想される、${targetGrade}レベルの漢字を選んでください。
                            2. 可能な限り、音読みと訓読みを織り交ぜて構成してください。
                            3. ${patternInstruction}
                            4. 1列の文字数は${rows}文字程度になるように調整し、縦のマスを埋めてください。
                            5. ${gradeSpecificPrompt}
                        `;
                        autoTitle = `${targetGrade}漢字ドリル - ${drillTheme}`;
                    } else {
                        specificInstruction = `
                            指示:
                            1. ${targetGrade}で習う代表的な漢字をランダムに選んでください。
                            2. 可能な限り、音読みと訓読みを織り交ぜて構成してください。
                            3. ${patternInstruction}
                            4. 1列の文字数は${rows}文字程度になるように調整し、縦のマスを埋めてください。
                            5. ${gradeSpecificPrompt}
                        `;
                        autoTitle = `${targetGrade}漢字ドリル - おまかせ練習`;
                    }

                    const prompt = `
                        あなたは日本の国語教師です。以下の条件に合わせて、漢字書き取り練習用のテキストを作成してください。

                        基本条件:
                        1. 対象学年: ${targetGrade}
                        2. 作成する列数: ${totalCols}列
                        3. 1列あたりの文字数: 絶対に${rows}文字以下にしてください。（これを超えるとペナルティ）

                        【最重要・空白埋めルール】:
                        生成されたテキストが${rows}文字に満たない場合は、
                        **「空白を残さず、既に作成した熟語や文章を最初から繰り返して」**、
                        必ず最後のマスまで文字で埋め尽くしてください。
                        空白のマスを作ることは禁止です。
                        
                        ${specificInstruction}
                        
                        出力形式の厳守ルール:
                        1. 生成したテキストの全ての文字を「文字(ルビ)」の形式にしてください。
                        2. 漢字には正しい読み仮名を振ってください。
                        3. 【重要】ひらがな・カタカナにも、その文字自身をルビとして振ってください（例: 「は(は)」「し(し)」）。
                        4. 句読点（、。）は含めないでください。
                        5. 1列ごとに改行を入れてください。
                        6. 出力には、生成されたテキストデータのみを含めてください。説明や挨拶は不要です。
                        
                        出力フォーマット例（1行が1列になります。rows=8の場合）:
                        競(きそ)競(きそ)競(きそ)競(きそ)競(きそ)う(う)
                        憲(けん)憲(けん)憲(けん)憲(けん)憲(けん)法(ぽう)
                        復(ふく)復(ふく)復(ふく)復(ふく)雑(ざつ)
                    `;
                    
                    // Step 1: ドリル内容の生成
                    const draftResult = await callGemini(prompt);
                    
                    // Step 2: フォーマットの整形（ルビ振り機能の適用）
                    const formatPrompt = `
                        あなたは日本の国語教師です。以下のテキストを、漢字練習用のマス目に入れるために分解・整形してください。
                        
                        修正ルール:
                        1. すべての文字を「文字(ルビ)」の形式に変換してください。
                        2. 「春分(しゅんぶん)」のように熟語でまとまっている場合は、「春(しゅん)分(ぶん)」のように一文字ずつに分解してください。
                        3. 漢字には正しい読み仮名を振ってください。
                        4. 【重要】ひらがな・カタカナにも、その文字自身をルビとして振ってください（例: 「は(は)」「し(し)」）。
                        5. 句読点（、。）も「、(、)」のように変換してください。
                        6. 改行位置は元のテキストに従ってください。
                        7. 【最重要】各行の文字数は絶対に${rows}文字を超えないようにしてください。超えている場合は、超えた分を削除してください。
                        
                        入力テキスト:
                        ${draftResult}
                    `;

                    const finalResult = await callGemini(formatPrompt);
                    setRawText(finalResult);
                    
                    if (autoTitle) {
                        setTitle(autoTitle);
                    }
                    
                } catch (err) {
                    console.error("AI Auto Generation Error:", err);
                    setErrorMsg(err.message || "ドリル生成に失敗しました。時間を空けて試してください。");
                } finally {
                    setIsGenerating(false);
                }
            };


            // --- Parsing Logic ---
            useEffect(() => {
                const lines = rawText.split('\n');
                const parsed = lines.map(line => {
                    const items = [];
                    let i = 0;
                    while (i < line.length) {
                        const remaining = line.slice(i);
                        const match = remaining.match(/^([^(\n]+)\(([^)]+)\)/);
                        if (match) {
                            items.push({
                                char: match[1],
                                ruby: match[2],
                                isKanji: true 
                            });
                            i += match[0].length;
                        } else {
                            items.push({
                                char: line[i],
                                ruby: line[i], 
                                isKanji: true
                            });
                            i++;
                        }
                    }
                    return items;
                });
                setParsedLines(parsed);
            }, [rawText]);

            // --- Grid Construction Logic ---
            const gridData = useMemo(() => {
                const formattedCols = [];
                for (let i = 0; i < parsedLines.length; i++) {
                    const lineItems = parsedLines[i];
                    if (lineItems.length === 0) {
                         formattedCols.push([]);
                    } else {
                        const chunk = lineItems.slice(0, rows);
                        formattedCols.push(chunk);
                    }
                }

                const grid = [];
                for (let c = 0; c < cols; c++) {
                    const colItems = formattedCols[c] || []; 
                    const columnCells = [];
                    for (let r = 0; r < rows; r++) {
                        if (r < colItems.length) {
                            columnCells.push(colItems[r]);
                        } else {
                            columnCells.push(null);
                        }
                    }
                    grid.push(columnCells);
                }
                return grid;
            }, [parsedLines, cols, rows]);

            // --- Save & Load Logic ---
            const saveDrill = () => {
                const newSave = {
                    id: Date.now(),
                    date: new Date().toLocaleString(),
                    title,
                    rawText,
                    rows,
                    cols,
                    orientation,
                    mode,
                    fontFamily,
                    showGuide,
                    showRubyText,
                    showKanjiText
                };
                
                const updatedSaves = [newSave, ...savedDrills].slice(0, MAX_SAVES);
                setSavedDrills(updatedSaves);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedSaves));
                alert("ドリルを保存しました！");
            };

            const loadDrill = (drill) => {
                setLoadTargetDrill(drill);
            };

            const executeLoad = () => {
                const drill = loadTargetDrill;
                if (!drill) return;
                setTitle(drill.title);
                setRawText(drill.rawText);
                setRows(drill.rows);
                setCols(drill.cols);
                setOrientation(drill.orientation);
                setMode(drill.mode);
                setFontFamily(drill.fontFamily || FONT_OPTIONS[0].family);
                setShowGuide(drill.showGuide);
                if (drill.showRubyText !== undefined) setShowRubyText(drill.showRubyText);
                if (drill.showKanjiText !== undefined) setShowKanjiText(drill.showKanjiText);
                setLoadTargetDrill(null);
            };

            const deleteDrill = (id) => {
                setDeleteTargetId(id);
            };

            const executeDelete = () => {
                if (!deleteTargetId) return;
                const updatedSaves = savedDrills.filter(s => s.id !== deleteTargetId);
                setSavedDrills(updatedSaves);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedSaves));
                setDeleteTargetId(null);
            };

            // --- Excel Export Logic ---
            const exportToExcel = () => {
                const ws_data = [];
                // 修正: Excel出力の列順序を逆転 (PDFの右→左レイアウトに合わせるため)
                // ドリルの右端の列(データの先頭)が、Excelの右側の列に来るようにする
                for (let r = 0; r < rows; r++) {
                    const rowData = [];
                    // cols-1 (データの最後/左端) から 0 (データの最初/右端) へ向かってループ
                    for (let c = cols - 1; c >= 0; c--) {
                        const cell = gridData[c][r];
                        if (cell) {
                            // 修正: 漢字を先、ルビを後に
                            rowData.push(cell.char); // 漢字
                            rowData.push(cell.ruby); // ルビ
                        } else {
                            rowData.push(""); // 空白
                            rowData.push(""); // 空白
                        }
                    }
                    ws_data.push(rowData);
                }

                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.aoa_to_sheet(ws_data);
                
                const wscols = [];
                for (let c = 0; c < cols; c++) {
                    wscols.push({ wch: 10 }); // 文字列 (漢字)
                    wscols.push({ wch: 6 });  // ルビ列
                }
                ws['!cols'] = wscols;

                XLSX.utils.book_append_sheet(wb, ws, "漢字ドリルデータ");
                XLSX.writeFile(wb, `${title}.xlsx`);
            };

            // --- Handlers ---
            const handlePrint = () => {
                const target = document.getElementById('print-target');
                if (!target) { alert("印刷対象が見つかりません"); return; }
                const contentHtml = target.outerHTML;

                const pageStyle = orientation === 'landscape' 
                    ? '@page { size: A4 landscape; margin: 0; }' 
                    : '@page { size: A4 portrait; margin: 0; }';

                const printWindow = window.open('', '_blank', 'height=800,width=1000');
                if (!printWindow) { alert("ポップアップがブロックされました。"); return; }

                printWindow.document.write(`
                    <html>
                    <head>
                        <meta charset="UTF-8">
                        <title>${title}</title>
                        <script src="https://cdn.tailwindcss.com"><\/script>
                        <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;500;700&display=swap" rel="stylesheet">
                        <link href="https://fonts.googleapis.com/css2?family=Yuji+Syuku&display=swap" rel="stylesheet">
                        <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
                        <link href="https://fonts.googleapis.com/css2?family=Kaisei+Decol:wght@400;700&display=swap" rel="stylesheet">
                        <link href="https://fonts.googleapis.com/css2?family=Zen+Kurenaido&display=swap" rel="stylesheet">
                        <link href="https://fonts.googleapis.com/css2?family=BIZ+UDPGothic:wght@400;700&family=BIZ+UDPMincho:wght@400;700&display=swap" rel="stylesheet">
                        <style>
                            body {
                                font-family: 'Zen Maru Gothic', sans-serif;
                                background-color: white;
                                margin: 0; padding: 0;
                                display: flex; justify-content: center; align-items: center;
                                -webkit-print-color-adjust: exact; print-color-adjust: exact;
                            }
                            /* 選択されたフォントを適用するためのクラス */
                            .dynamic-font {
                                font-family: ${fontFamily};
                            }
                            .tategaki { writing-mode: vertical-rl; text-orientation: upright; font-feature-settings: "vhal" 1; }
                            .guide-lines { position: relative; }
                            .guide-lines::before {
                                content: ''; position: absolute; top: 0; bottom: 0; left: 50%;
                                border-left: 1px dashed #d1d5db; z-index: 0; pointer-events: none;
                            }
                            .guide-lines::after {
                                content: ''; position: absolute; left: 0; right: 0; top: 50%;
                                border-top: 1px dashed #d1d5db; z-index: 0; pointer-events: none;
                            }
                            ${pageStyle}
                            #print-target { transform: none !important; margin: 0 auto !important; box-shadow: none !important; }
                        </style>
                    </head>
                    <body>
                        ${contentHtml}
                        <script>
                            setTimeout(function() { window.print(); }, 1000); 
                        <\/script>
                    </body>
                    </html>
                `);
                printWindow.document.close();
                printWindow.focus();
            };

            const applyPreset = (type) => {
                const isPortrait = orientation === 'portrait';
                switch(type) {
                    case 'low': if (isPortrait) { setRows(6); setCols(5); } else { setRows(5); setCols(8); } setShowGuide(true); break;
                    case 'mid': if (isPortrait) { setRows(8); setCols(7); } else { setRows(7); setCols(10); } setShowGuide(true); break;
                    case 'high': if (isPortrait) { setRows(12); setCols(9); } else { setRows(10); setCols(13); } setShowGuide(true); break;
                    case 'junior': if (isPortrait) { setRows(18); setCols(12); } else { setRows(15); setCols(18); } setShowGuide(false); break;
                }
            };

            return (
                <div className="min-h-screen md:h-screen flex flex-col md:flex-row bg-gray-100 font-sans md:overflow-hidden">
                    {/* --- Sidebar (Left) --- */}
                    <div className="w-full md:w-80 bg-white border-r border-gray-200 shadow-lg z-10 flex flex-col h-auto md:h-full no-print overflow-y-auto">
                        <div className="p-4 bg-indigo-700 text-white shadow-md sticky top-0 z-20">
                            <h1 className="text-lg font-bold flex items-center gap-2">
                                <BookOpen size={20} />
                                AI漢字ドリル作成
                            </h1>
                        </div>

                        {/* ==============================================
                            New: API Key Settings (Top of Sidebar)
                           ============================================== */}
                        <div className="border-b border-gray-200 bg-gray-50">
                            <button 
                                onClick={() => setIsApiKeyOpen(!isApiKeyOpen)}
                                className="w-full px-4 py-2 flex items-center justify-between text-xs font-bold text-gray-600 hover:bg-gray-100 transition-colors"
                            >
                                <div className="flex items-center gap-2">
                                    <Key size={14} className="text-indigo-500" />
                                    Google AI 設定 (APIキー)
                                </div>
                                {isApiKeyOpen ? <ChevronUp size={14} /> : <ChevronDown size={14} />}
                            </button>
                            
                            {isApiKeyOpen && (
                                <div className="px-4 pb-4 animate-fade-in bg-white border-b border-gray-200 shadow-inner p-4">
                                    <p className="text-[10px] text-gray-500 mb-2 leading-tight">
                                        AI機能を利用するにはGoogle Gemini APIキーが必要です。入力されたキーはブラウザにのみ保存されます。
                                    </p>
                                    
                                    <div className="relative mb-2">
                                        <input 
                                            type={showApiKeyChar ? "text" : "password"}
                                            value={userApiKey}
                                            onChange={handleApiKeyChange}
                                            placeholder="AIzaSy..."
                                            className="w-full pl-2 pr-8 py-1.5 text-xs border border-gray-300 rounded focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500 bg-gray-50 font-mono"
                                        />
                                        <button 
                                            className="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600"
                                            onClick={() => setShowApiKeyChar(!showApiKeyChar)}
                                        >
                                            {showApiKeyChar ? <EyeOff size={14} /> : <Eye size={14} />}
                                        </button>
                                    </div>

                                    <a 
                                        href="https://aistudio.google.com/app/apikey" 
                                        target="_blank" 
                                        rel="noopener noreferrer"
                                        className="flex items-center gap-1 text-[10px] text-indigo-600 hover:text-indigo-800 font-bold hover:underline"
                                    >
                                        <ExternalLink size={10} />
                                        APIキーを無料で取得 (Google AI Studio)
                                    </a>
                                </div>
                            )}
                        </div>

                        <div className="p-4 space-y-6 flex-1">
                            {/* AI Input */}
                            <div className="space-y-3">
                                <div className="flex items-center justify-between">
                                    <label className="text-xs font-bold text-gray-500 flex items-center gap-1 uppercase tracking-wider">
                                        <Sparkles size={14} className="text-indigo-500" />
                                        AI 入力支援
                                    </label>
                                    
                                    {/* AI Mode Toggle */}
                                    <div className="flex bg-gray-100 rounded p-0.5">
                                        <button 
                                            onClick={() => setAiMode('auto')} 
                                            className={`px-2 py-0.5 text-[10px] font-bold rounded ${aiMode === 'auto' ? 'bg-white shadow text-indigo-600' : 'text-gray-400'}`}
                                        >
                                            自動作成
                                        </button>
                                        <button 
                                            onClick={() => setAiMode('manual')} 
                                            className={`px-2 py-0.5 text-[10px] font-bold rounded ${aiMode === 'manual' ? 'bg-white shadow text-indigo-600' : 'text-gray-400'}`}
                                        >
                                            ルビ振り
                                        </button>
                                    </div>
                                </div>

                                {aiMode === 'auto' ? (
                                    <div className="bg-indigo-50 p-3 rounded border border-indigo-100 space-y-3 animate-fade-in">
                                        <div className="space-y-1">
                                            <label className="text-[10px] font-bold text-indigo-600">対象学年</label>
                                            <select 
                                                value={targetGrade} 
                                                onChange={(e) => setTargetGrade(e.target.value)}
                                                className="w-full p-1.5 text-xs border border-indigo-200 rounded"
                                            >
                                                <option value="小1">小学1年生</option>
                                                <option value="小2">小学2年生</option>
                                                <option value="小3">小学3年生</option>
                                                <option value="小4">小学4年生</option>
                                                <option value="小5">小学5年生</option>
                                                <option value="小6">小学6年生</option>
                                                <option value="中学">中学生</option>
                                            </select>
                                        </div>
                                        <div className="space-y-1">
                                            <label className="text-[10px] font-bold text-indigo-600">テーマ (任意)</label>
                                            <input 
                                                type="text" 
                                                value={drillTheme}
                                                onChange={(e) => setDrillTheme(e.target.value)}
                                                placeholder="例: 運動会、夏休み、歴史"
                                                className="w-full p-1.5 text-xs border border-indigo-200 rounded"
                                            />
                                        </div>
                                        <div className="space-y-1">
                                            <label className="text-[10px] font-bold text-indigo-600 flex items-center">
                                                使用する漢字 (任意)
                                                {targetGrade === '小1' && <span className="text-red-500 text-[9px] ml-1 font-bold">※ひらがな対応可</span>}
                                            </label>
                                            <textarea 
                                                value={targetKanji}
                                                onChange={(e) => setTargetKanji(e.target.value)}
                                                placeholder="例: 赤、赤ちゃん、赤い玉..." 
                                                rows={3}
                                                className="w-full p-1.5 text-xs border border-indigo-200 rounded resize-none"
                                            />
                                            <p className="text-[10px] text-gray-400">※先生入力モードではここに入力された内容がそのままドリルになります。</p>
                                        </div>
                                        <div className="space-y-1">
                                            <label className="text-[10px] font-bold text-indigo-600">構成パターン</label>
                                            <select 
                                                value={drillPattern} 
                                                onChange={(e) => setDrillPattern(e.target.value)}
                                                className="w-full p-1.5 text-xs border border-indigo-200 rounded"
                                            >
                                                <option value="all">単漢字のみ (美 美 美 美)</option>
                                                <option value="half">基本 (単漢字 + 熟語)</option>
                                                <option value="idiom_focus">熟語重視 (単漢字1 + 多熟語)</option>
                                                <option value="mix">応用 (単漢字 + 熟語 + 短文)</option>
                                                <option value="sentence_focus">実践 (単漢字1 + 熟語少 + 短文)</option>
                                                <option value="teacher_input">先生入力 (入力順に配置)</option>
                                            </select>
                                        </div>
                                        <button
                                            onClick={autoGenerateDrill}
                                            disabled={isGenerating}
                                            className={`w-full py-2 px-3 rounded text-xs font-bold text-white shadow flex items-center justify-center gap-2
                                                ${isGenerating ? 'bg-gray-400' : 'bg-gradient-to-r from-indigo-500 to-purple-500 hover:from-indigo-600 hover:to-purple-600'}`}
                                        >
                                            {isGenerating ? "AIが考え中..." : <><BrainCircuit size={14} /> ドリルを作成！</>}
                                        </button>
                                        <p className="text-[10px] text-indigo-400 leading-tight">
                                            ※マス目を埋めるように自動で生成します。
                                        </p>
                                    </div>
                                ) : (
                                    <div className="space-y-2 animate-fade-in">
                                        <textarea
                                            className="w-full h-96 p-2 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500 text-sm resize-none"
                                            placeholder="ここに文章を入力..."
                                            value={rawText}
                                            onChange={(e) => setRawText(e.target.value)}
                                        />
                                        <button
                                            onClick={generateRuby}
                                            disabled={isGenerating}
                                            className={`w-full py-2 px-3 rounded text-sm font-bold text-white shadow transition-all flex items-center justify-center gap-2
                                                ${isGenerating ? 'bg-gray-400' : 'bg-indigo-600 hover:bg-indigo-700'}`}
                                        >
                                            {isGenerating ? "解析中..." : "AIでルビを振る"}
                                        </button>
                                    </div>
                                )}
                                
                                {errorMsg && <p className="text-xs text-red-500 bg-red-50 p-1 rounded font-bold">{errorMsg}</p>}
                            </div>

                            <hr className="border-gray-100" />

                            {/* Settings */}
                            <div className="space-y-4">
                                <h2 className="text-xs font-bold text-gray-500 flex items-center gap-1 uppercase tracking-wider">
                                    <Settings size={14} />
                                    レイアウト設定
                                </h2>

                                {/* Font Selection */}
                                <div>
                                    <label className="text-xs font-bold text-gray-500 mb-1 block flex items-center gap-1">
                                        <Type size={12} /> フォント
                                    </label>
                                    <select 
                                        value={fontFamily} 
                                        onChange={(e) => setFontFamily(e.target.value)}
                                        className="w-full p-2 border border-gray-300 rounded text-sm"
                                    >
                                        {FONT_OPTIONS.map(font => (
                                            <option key={font.id} value={font.family}>{font.name}</option>
                                        ))}
                                    </select>
                                </div>
                                
                                {/* Orientation & Presets */}
                                <div className="space-y-2">
                                    <div className="flex bg-gray-100 p-1 rounded">
                                        <button onClick={() => setOrientation('portrait')} className={`flex-1 flex items-center justify-center gap-1 py-1 text-xs font-bold rounded ${orientation === 'portrait' ? 'bg-white shadow text-indigo-700' : 'text-gray-500'}`}><FileText size={14} /> 縦向き (基本)</button>
                                        <button onClick={() => setOrientation('landscape')} className={`flex-1 flex items-center justify-center gap-1 py-1 text-xs font-bold rounded ${orientation === 'landscape' ? 'bg-white shadow text-indigo-700' : 'text-gray-500'}`}><LayoutTemplate size={14} /> 横向き</button>
                                    </div>

                                    <div className="grid grid-cols-2 gap-2">
                                        <button onClick={() => applyPreset('low')} className="px-2 py-1.5 text-xs bg-green-50 text-green-700 border border-green-200 rounded hover:bg-green-100 font-bold">低学年</button>
                                        <button onClick={() => applyPreset('mid')} className="px-2 py-1.5 text-xs bg-blue-50 text-blue-700 border border-blue-200 rounded hover:bg-blue-100 font-bold">中学年</button>
                                        <button onClick={() => applyPreset('high')} className="px-2 py-1.5 text-xs bg-purple-50 text-purple-700 border border-purple-200 rounded hover:bg-purple-100 font-bold">高学年</button>
                                        <button onClick={() => applyPreset('junior')} className="px-2 py-1.5 text-xs bg-gray-50 text-gray-700 border border-gray-200 rounded hover:bg-gray-100 font-bold">中学生</button>
                                    </div>
                                </div>

                                {/* Sliders */}
                                <div className="bg-white border border-gray-200 p-3 rounded space-y-3">
                                    <div>
                                        <div className="flex justify-between text-xs mb-1 font-bold text-gray-600">
                                            <span>縦のマス数 (文字数)</span>
                                            <span>{rows}</span>
                                        </div>
                                        <input type="range" min="2" max="25" value={rows} onChange={(e) => setRows(Number(e.target.value))} className="w-full h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-indigo-600" />
                                    </div>
                                    <div>
                                        <div className="flex justify-between text-xs mb-1 font-bold text-gray-600">
                                            <span>横の列数 (行数)</span>
                                            <span>{cols}</span>
                                        </div>
                                        <input type="range" min="1" max="20" value={cols} onChange={(e) => setCols(Number(e.target.value))} className="w-full h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-indigo-600" />
                                    </div>
                                </div>

                                {/* Toggles */}
                                <div className="space-y-2">
                                    <label className="flex items-center justify-between cursor-pointer p-2 hover:bg-gray-50 rounded">
                                        <span className="text-sm text-gray-700 font-medium">十字リーダー (補助線)</span>
                                        <div className={`w-10 h-5 flex items-center rounded-full p-1 duration-300 ease-in-out ${showGuide ? 'bg-indigo-600' : 'bg-gray-300'}`}>
                                            <div className={`bg-white w-3 h-3 rounded-full shadow-md transform duration-300 ease-in-out ${showGuide ? 'translate-x-5' : ''}`} />
                                        </div>
                                        <input type="checkbox" checked={showGuide} onChange={(e) => setShowGuide(e.target.checked)} className="hidden" />
                                    </label>
                                    
                                    {/* Ruby Toggle */}
                                    <div className="flex gap-2">
                                        <label className="flex-1 flex items-center justify-between cursor-pointer p-2 hover:bg-gray-50 rounded bg-gray-50 border border-gray-100">
                                            <span className="text-xs text-gray-700 font-medium">ルビ</span>
                                            <div className={`w-8 h-4 flex items-center rounded-full p-0.5 duration-300 ease-in-out ${showRubyText ? 'bg-indigo-600' : 'bg-gray-300'}`}>
                                                <div className={`bg-white w-3 h-3 rounded-full shadow-md transform duration-300 ease-in-out ${showRubyText ? 'translate-x-4' : ''}`} />
                                            </div>
                                            <input type="checkbox" checked={showRubyText} onChange={(e) => setShowRubyText(e.target.checked)} className="hidden" />
                                        </label>
                                        <label className="flex-1 flex items-center justify-between cursor-pointer p-2 hover:bg-gray-50 rounded bg-gray-50 border border-gray-100">
                                            <span className="text-xs text-gray-700 font-medium">本文(漢字)</span>
                                            <div className={`w-8 h-4 flex items-center rounded-full p-0.5 duration-300 ease-in-out ${showKanjiText ? 'bg-indigo-600' : 'bg-gray-300'}`}>
                                                <div className={`bg-white w-3 h-3 rounded-full shadow-md transform duration-300 ease-in-out ${showKanjiText ? 'translate-x-4' : ''}`} />
                                            </div>
                                            <input type="checkbox" checked={showKanjiText} onChange={(e) => setShowKanjiText(e.target.checked)} className="hidden" />
                                        </label>
                                    </div>
                                </div>
                            </div>

                            <hr className="border-gray-100" />

                            {/* Mode & Title */}
                            <div className="space-y-4">
                                <div>
                                    <h2 className="text-xs font-bold text-gray-500 mb-2 uppercase tracking-wider flex items-center gap-1">
                                        <PenTool size={14} /> 練習モード
                                    </h2>
                                    <div className="flex bg-gray-100 p-1 rounded">
                                        {['trace', 'practice', 'empty'].map((m) => (
                                            <button
                                                key={m}
                                                onClick={() => setMode(m)}
                                                className={`flex-1 py-1.5 text-xs font-bold rounded transition-all ${mode === m ? 'bg-white text-indigo-700 shadow' : 'text-gray-500 hover:text-gray-700'}`}
                                            >
                                                {m === 'trace' && 'なぞり'}
                                                {m === 'practice' && '見写し'}
                                                {m === 'empty' && '空欄'}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                                
                                <div>
                                    <label className="text-xs font-bold text-gray-500 mb-1 block">タイトル</label>
                                    <input type="text" value={title} onChange={(e) => setTitle(e.target.value)} className="w-full p-2 border border-gray-300 rounded text-sm" />
                                </div>
                            </div>

                            {/* Save / Load / Excel */}
                            <div className="bg-blue-50 p-3 rounded border border-blue-100 space-y-3">
                                <div className="flex gap-2">
                                    <button onClick={saveDrill} className="flex-1 py-1.5 bg-blue-600 text-white text-xs font-bold rounded hover:bg-blue-700 flex items-center justify-center gap-1">
                                        <Save size={14} /> 保存する
                                    </button>
                                    <button onClick={exportToExcel} className="flex-1 py-1.5 bg-green-600 text-white text-xs font-bold rounded hover:bg-green-700 flex items-center justify-center gap-1">
                                        <Download size={14} /> Excel出力
                                    </button>
                                </div>
                                
                                {savedDrills.length > 0 && (
                                    <div className="mt-2">
                                        <h3 className="text-xs font-bold text-gray-500 mb-1">保存したドリル</h3>
                                        <div className="max-h-32 overflow-y-auto space-y-1">
                                            {savedDrills.map(drill => (
                                                <div key={drill.id} className="flex items-center justify-between bg-white p-2 rounded border border-gray-200 text-xs">
                                                    <div className="flex-1 cursor-pointer truncate" onClick={() => loadDrill(drill)}>
                                                        <span className="font-bold text-gray-700 block truncate">{drill.title}</span>
                                                        <span className="text-gray-400 text-[10px]">{drill.date}</span>
                                                    </div>
                                                    <button onClick={() => deleteDrill(drill.id)} className="text-red-400 hover:text-red-600 p-1">
                                                        <Trash2 size={12} />
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        <div className="p-4 border-t bg-gray-50">
                            <button onClick={handlePrint} className="w-full py-3 bg-gray-800 hover:bg-gray-900 text-white rounded shadow-lg font-bold flex items-center justify-center gap-2">
                                <Printer size={18} />
                                印刷する (A4)
                            </button>
                        </div>
                    </div>

                    {/* --- Preview Area (Right) --- */}
                    <div className="flex-1 bg-gray-300 overflow-hidden flex flex-col relative h-auto md:h-full">
                        {/* Zoom Controls */}
                        <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-white/90 backdrop-blur px-4 py-2 rounded-full shadow-lg z-20 flex items-center gap-4 no-print border border-gray-200">
                            <div className="flex items-center gap-2">
                                <ZoomIn size={16} className="text-gray-600" />
                                <input 
                                    type="range" 
                                    min="0.3" 
                                    max="1.5" 
                                    step="0.1" 
                                    value={zoom} 
                                    onChange={(e) => setZoom(Number(e.target.value))}
                                    className="w-32 h-1.5 bg-gray-300 rounded-lg appearance-none cursor-pointer accent-indigo-600"
                                />
                                <span className="text-xs font-mono w-8 text-right">{Math.round(zoom * 100)}%</span>
                            </div>
                        </div>

                        {/* Scrollable Container (Fixed Layout Logic) */}
                        <div className="flex-1 overflow-auto relative w-full h-full flex flex-col">
                            {/* 中央寄せ & 自動余白調整ラッパー */}
                            <div className="m-auto p-8 md:p-12 pt-24 transition-transform duration-200" id="print-target-wrapper">
                                {/* Paper Sheet - Added ID for Printing */}
                                <div id="print-target" className="bg-white shadow-2xl print-area" style={{ 
                                    width: `${paperSize.width}mm`, 
                                    height: `${paperSize.height}mm`, 
                                    padding: `${PADDING}mm`,
                                    boxSizing: 'border-box',
                                    transform: `scale(${zoom})`, // ズーム適用
                                }}>
                                    {/* Header 修正: タイトルと名前欄を完全に独立させつつ、縦の余白を詰めるレイアウト */}
                                    <div className="w-full flex justify-between items-end pb-1 mb-1 border-b-2 border-gray-800" style={{ height: `${HEADER_HEIGHT}mm` }}>
                                        {/* タイトル行: 左上詰め。絶対配置はやめてFlexboxで配置 */}
                                        <h1 className="font-bold text-gray-800 leading-none dynamic-font mb-auto" style={{ fontSize: '16pt', fontFamily: fontFamily }}>{title}</h1>
                                    
                                        {/* 名前行: 右寄せ、幅広め */}
                                        <div className="flex items-end gap-6 text-base text-gray-700 leading-none dynamic-font" style={{ fontFamily: fontFamily }}>
                                            <div className="flex items-end gap-1"><div className="w-10 border-b border-gray-800"></div><span>年</span></div>
                                            <div className="flex items-end gap-1"><div className="w-10 border-b border-gray-800"></div><span>組</span></div>
                                            <div className="flex items-end gap-1">
                                                <span>名前</span>
                                                <div className="w-60 border-b border-gray-800"></div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Main Grid Container */}
                                    <div className="w-full flex flex-row-reverse border-2 border-gray-800 bg-white" style={{ height: `${GRID_AREA_HEIGHT}mm` }}>
                                        {gridData.map((colData, colIndex) => (
                                            <div key={colIndex} className="flex flex-col border-l border-gray-400 first:border-l-0" 
                                                style={{ 
                                                    width: layoutStyles.colWidth,
                                                    flexShrink: 0,
                                                }}>
                                                {colData.map((cell, rowIndex) => {
                                                    const hasData = cell !== null;
                                                    
                                                    // 表示モード制御
                                                    let charClass = "text-gray-900";
                                                    let showChar = true;
                                                    let showRuby = true;

                                                    if (!hasData) {
                                                        showChar = false;
                                                        showRuby = false;
                                                    } else {
                                                        if (mode === 'trace') charClass = "text-gray-300";
                                                        else if (mode === 'practice') charClass = "text-gray-900";
                                                        else if (mode === 'empty') { showChar = false; showRuby = false; }
                                                    }

                                                    // ルビの表示制御
                                                    const displayRuby = showRuby && showRubyText;
                                                    
                                                    // 漢字の表示制御 (句読点の場合は常に表示)
                                                    const isPunctuation = hasData && ['、', '。'].includes(cell.char);
                                                    const displayKanji = (showChar && showKanjiText) || isPunctuation;

                                                    // ひらがなも漢字も同じ色で表示
                                                    const rubyColorClass = charClass;

                                                    // 句読点用のスタイル調整
                                                    const charStyle = { 
                                                        fontSize: layoutStyles.charFontSize, 
                                                        lineHeight: 1,
                                                        whiteSpace: 'nowrap',
                                                        fontFamily: fontFamily,
                                                    };

                                                    if (isPunctuation) {
                                                        // 句読点を右上に配置するためのスタイル
                                                        Object.assign(charStyle, {
                                                            position: 'absolute',
                                                            top: '5%',
                                                            right: '5%',
                                                            transform: 'translate(10%, -10%)', // 微調整
                                                        });
                                                    }

                                                    return (
                                                        <div key={rowIndex} className="flex flex-row-reverse border-b border-gray-400 last:border-b-0" 
                                                            style={{ height: layoutStyles.cellHeight, minHeight: 0, overflow: 'hidden' }}>
                                                            
                                                            {/* ルビ欄 */}
                                                            <div className="border-l border-dotted border-gray-300 flex items-center justify-center tategaki"
                                                                 style={{ width: layoutStyles.rubyWidth }}>
                                                                <span className={`dynamic-font ${rubyColorClass}`} 
                                                                    style={{ 
                                                                        fontSize: layoutStyles.rubyFontSize, 
                                                                        fontFamily: fontFamily,
                                                                        lineHeight: 1,
                                                                        whiteSpace: 'nowrap'
                                                                    }}>
                                                                    {displayRuby ? cell.ruby : ''}
                                                                </span>
                                                            </div>
                                                            
                                                            {/* 漢字欄 */}
                                                            <div className={`flex items-center justify-center relative dynamic-font ${showGuide ? 'guide-lines' : ''}`}
                                                                 style={{ width: layoutStyles.charWidth, fontFamily: fontFamily }}>
                                                                <span className={charClass} style={charStyle}>
                                                                    {displayKanji ? cell.char : ''}
                                                                </span>
                                                            </div>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    {/* モーダルの配置 */}
                    <ConfirmModal 
                        isOpen={!!deleteTargetId} 
                        onClose={() => setDeleteTargetId(null)} 
                        onConfirm={executeDelete} 
                        message="この保存データを削除しますか？" 
                        confirmText="削除する"
                        confirmColor="bg-red-500"
                    />
                    
                    <ConfirmModal 
                        isOpen={!!loadTargetDrill} 
                        onClose={() => setLoadTargetDrill(null)} 
                        onConfirm={executeLoad} 
                        message={`「${loadTargetDrill?.title}」を読み込みますか？\n現在の編集内容は失われます。`} 
                        confirmText="読み込む"
                        confirmColor="bg-blue-600"
                    />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
